[
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "maxsize",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "plot_covariance_ellipse",
        "importPath": "Utils.angle.plot",
        "description": "Utils.angle.plot",
        "isExtraImport": true,
        "detail": "Utils.angle.plot",
        "documentation": {}
    },
    {
        "label": "plot_covariance_ellipse",
        "importPath": "Utils.angle.plot",
        "description": "Utils.angle.plot",
        "isExtraImport": true,
        "detail": "Utils.angle.plot",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "norm",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "total_ordering",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "plot_3d_vector_arrow",
        "importPath": "utils.plot",
        "description": "utils.plot",
        "isExtraImport": true,
        "detail": "utils.plot",
        "documentation": {}
    },
    {
        "label": "plot_triangle",
        "importPath": "utils.plot",
        "description": "utils.plot",
        "isExtraImport": true,
        "detail": "utils.plot",
        "documentation": {}
    },
    {
        "label": "set_equal_3d_axis",
        "importPath": "utils.plot",
        "description": "utils.plot",
        "isExtraImport": true,
        "detail": "utils.plot",
        "documentation": {}
    },
    {
        "label": "numpy.typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy.typing",
        "description": "numpy.typing",
        "detail": "numpy.typing",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "rot_mat_2d",
        "importPath": "Utils.angle.angle",
        "description": "Utils.angle.angle",
        "isExtraImport": true,
        "detail": "Utils.angle.angle",
        "documentation": {}
    },
    {
        "label": "rot_mat_2d",
        "importPath": "Utils.angle.angle",
        "description": "Utils.angle.angle",
        "isExtraImport": true,
        "detail": "Utils.angle.angle",
        "documentation": {}
    },
    {
        "label": "rot_mat_2d",
        "importPath": "Utils.angle.angle",
        "description": "Utils.angle.angle",
        "isExtraImport": true,
        "detail": "Utils.angle.angle",
        "documentation": {}
    },
    {
        "label": "angle_mod",
        "importPath": "Utils.angle.angle",
        "description": "Utils.angle.angle",
        "isExtraImport": true,
        "detail": "Utils.angle.angle",
        "documentation": {}
    },
    {
        "label": "angle_mod",
        "importPath": "Utils.angle.angle",
        "description": "Utils.angle.angle",
        "isExtraImport": true,
        "detail": "Utils.angle.angle",
        "documentation": {}
    },
    {
        "label": "angle_mod",
        "importPath": "Utils.angle.angle",
        "description": "Utils.angle.angle",
        "isExtraImport": true,
        "detail": "Utils.angle.angle",
        "documentation": {}
    },
    {
        "label": "angle_mod",
        "importPath": "Utils.angle.angle",
        "description": "Utils.angle.angle",
        "isExtraImport": true,
        "detail": "Utils.angle.angle",
        "documentation": {}
    },
    {
        "label": "angle_mod",
        "importPath": "Utils.angle.angle",
        "description": "Utils.angle.angle",
        "isExtraImport": true,
        "detail": "Utils.angle.angle",
        "documentation": {}
    },
    {
        "label": "rot_mat_2d",
        "importPath": "Utils.angle.angle",
        "description": "Utils.angle.angle",
        "isExtraImport": true,
        "detail": "Utils.angle.angle",
        "documentation": {}
    },
    {
        "label": "bisect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bisect",
        "description": "bisect",
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "GridMap",
        "importPath": "Mapping.grid_map_lib.grid_map_lib",
        "description": "Mapping.grid_map_lib.grid_map_lib",
        "isExtraImport": true,
        "detail": "Mapping.grid_map_lib.grid_map_lib",
        "documentation": {}
    },
    {
        "label": "FloatGrid",
        "importPath": "Mapping.grid_map_lib.grid_map_lib",
        "description": "Mapping.grid_map_lib.grid_map_lib",
        "isExtraImport": true,
        "detail": "Mapping.grid_map_lib.grid_map_lib",
        "documentation": {}
    },
    {
        "label": "cvxpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cvxpy",
        "description": "cvxpy",
        "detail": "cvxpy",
        "documentation": {}
    },
    {
        "label": "cubic_spline_planner",
        "importPath": "PathPlanning.CubicSpline",
        "description": "PathPlanning.CubicSpline",
        "isExtraImport": true,
        "detail": "PathPlanning.CubicSpline",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "SparseEfficiencyWarning",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "lil_matrix",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "spsolve",
        "importPath": "scipy.sparse.linalg",
        "description": "scipy.sparse.linalg",
        "isExtraImport": true,
        "detail": "scipy.sparse.linalg",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "Rotation",
        "importPath": "scipy.spatial.transform",
        "description": "scipy.spatial.transform",
        "isExtraImport": true,
        "detail": "scipy.spatial.transform",
        "documentation": {}
    },
    {
        "label": "Rotation",
        "importPath": "scipy.spatial.transform",
        "description": "scipy.spatial.transform",
        "isExtraImport": true,
        "detail": "scipy.spatial.transform",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "art3d",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "FancyArrowPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "proj_transform",
        "importPath": "mpl_toolkits.mplot3d.proj3d",
        "description": "mpl_toolkits.mplot3d.proj3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d.proj3d",
        "documentation": {}
    },
    {
        "label": "calc_input",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "def calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]\n    u = np.array([[v], [yawrate]])\n    return u\ndef observation(xTrue, xd, u):\n    xTrue = motion_model(xTrue, u)\n    # add noise to gps x-y\n    z = observation_model(xTrue) + GPS_NOISE @ np.random.randn(2, 1)\n    # add noise to input",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "observation",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "def observation(xTrue, xd, u):\n    xTrue = motion_model(xTrue, u)\n    # add noise to gps x-y\n    z = observation_model(xTrue) + GPS_NOISE @ np.random.randn(2, 1)\n    # add noise to input\n    ud = u + INPUT_NOISE @ np.random.randn(2, 1)\n    xd = motion_model(xd, ud)\n    return xTrue, z, xd, ud\ndef motion_model(x, u):\n    F = np.array([[1.0, 0, 0, 0, 0],",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "motion_model",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "def motion_model(x, u):\n    F = np.array([[1.0, 0, 0, 0, 0],\n                  [0, 1.0, 0, 0, 0],\n                  [0, 0, 1.0, 0, 0],\n                  [0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 1.0]])\n    B = np.array([[DT * math.cos(x[2, 0]) * x[4, 0], 0],\n                  [DT * math.sin(x[2, 0]) * x[4, 0], 0],\n                  [0.0, DT],\n                  [1.0, 0.0],",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "observation_model",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "def observation_model(x):\n    H = np.array([\n        [1, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0]\n    ])\n    z = H @ x\n    return z\ndef jacob_f(x, u):\n    \"\"\"\n    Jacobian of Motion Model",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "jacob_f",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "def jacob_f(x, u):\n    \"\"\"\n    Jacobian of Motion Model\n    motion model\n    x_{t+1} = x_t+v*s*dt*cos(yaw)\n    y_{t+1} = y_t+v*s*dt*sin(yaw)\n    yaw_{t+1} = yaw_t+omega*dt\n    v_{t+1} = v{t}\n    s_{t+1} = s{t}\n    so",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "jacob_h",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "def jacob_h():\n    jH = np.array([[1, 0, 0, 0, 0],\n                   [0, 1, 0, 0, 0]])\n    return jH\ndef ekf_estimation(xEst, PEst, z, u):\n    #  Predict\n    xPred = motion_model(xEst, u)\n    jF = jacob_f(xEst, u)\n    PPred = jF @ PEst @ jF.T + Q\n    #  Update",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "ekf_estimation",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "def ekf_estimation(xEst, PEst, z, u):\n    #  Predict\n    xPred = motion_model(xEst, u)\n    jF = jacob_f(xEst, u)\n    PPred = jF @ PEst @ jF.T + Q\n    #  Update\n    jH = jacob_h()\n    zPred = observation_model(xPred)\n    y = z - zPred\n    S = jH @ PPred @ jH.T + R",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "def main():\n    print(__file__ + \" start!!\")\n    time = 0.0\n    #  State Vector [x y yaw v s]'\n    xEst = np.zeros((5, 1))\n    xEst[4, 0] = 1.0 #  Initial scale factor\n    xTrue = np.zeros((5, 1))\n    true_scale_factor = 0.9 #  True scale factor\n    xTrue[4, 0] = true_scale_factor\n    PEst = np.eye(5)",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "Q",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "Q = np.diag([\n    0.1,  # variance of location on x-axis\n    0.1,  # variance of location on y-axis\n    np.deg2rad(1.0),  # variance of yaw angle\n    0.4,  # variance of velocity\n    0.1  # variance of scale factor\n]) ** 2  # predict state covariance\nR = np.diag([0.1, 0.1]) ** 2  # Observation x,y position covariance\n#  Simulation parameter\nINPUT_NOISE = np.diag([0.1, np.deg2rad(5.0)]) ** 2",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "R",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "R = np.diag([0.1, 0.1]) ** 2  # Observation x,y position covariance\n#  Simulation parameter\nINPUT_NOISE = np.diag([0.1, np.deg2rad(5.0)]) ** 2\nGPS_NOISE = np.diag([0.05, 0.05]) ** 2\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nshow_animation = True\ndef calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "INPUT_NOISE",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "INPUT_NOISE = np.diag([0.1, np.deg2rad(5.0)]) ** 2\nGPS_NOISE = np.diag([0.05, 0.05]) ** 2\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nshow_animation = True\ndef calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]\n    u = np.array([[v], [yawrate]])\n    return u",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "GPS_NOISE",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "GPS_NOISE = np.diag([0.05, 0.05]) ** 2\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nshow_animation = True\ndef calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]\n    u = np.array([[v], [yawrate]])\n    return u\ndef observation(xTrue, xd, u):",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "DT",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "DT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nshow_animation = True\ndef calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]\n    u = np.array([[v], [yawrate]])\n    return u\ndef observation(xTrue, xd, u):\n    xTrue = motion_model(xTrue, u)",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "SIM_TIME",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "SIM_TIME = 50.0  # simulation time [s]\nshow_animation = True\ndef calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]\n    u = np.array([[v], [yawrate]])\n    return u\ndef observation(xTrue, xd, u):\n    xTrue = motion_model(xTrue, u)\n    # add noise to gps x-y",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "description": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "peekOfCode": "show_animation = True\ndef calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]\n    u = np.array([[v], [yawrate]])\n    return u\ndef observation(xTrue, xd, u):\n    xTrue = motion_model(xTrue, u)\n    # add noise to gps x-y\n    z = observation_model(xTrue) + GPS_NOISE @ np.random.randn(2, 1)",
        "detail": "Localization.extended_kalman_filter.ekf_with_velocity_correction",
        "documentation": {}
    },
    {
        "label": "calc_input",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "def calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]\n    u = np.array([[v], [yawrate]])\n    return u\ndef observation(xTrue, xd, u):\n    xTrue = motion_model(xTrue, u)\n    # add noise to gps x-y\n    z = observation_model(xTrue) + GPS_NOISE @ np.random.randn(2, 1)\n    # add noise to input",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "observation",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "def observation(xTrue, xd, u):\n    xTrue = motion_model(xTrue, u)\n    # add noise to gps x-y\n    z = observation_model(xTrue) + GPS_NOISE @ np.random.randn(2, 1)\n    # add noise to input\n    ud = u + INPUT_NOISE @ np.random.randn(2, 1)\n    xd = motion_model(xd, ud)\n    return xTrue, z, xd, ud\ndef motion_model(x, u):\n    F = np.array([[1.0, 0, 0, 0],",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "motion_model",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "def motion_model(x, u):\n    F = np.array([[1.0, 0, 0, 0],\n                  [0, 1.0, 0, 0],\n                  [0, 0, 1.0, 0],\n                  [0, 0, 0, 0]])\n    B = np.array([[DT * math.cos(x[2, 0]), 0],\n                  [DT * math.sin(x[2, 0]), 0],\n                  [0.0, DT],\n                  [1.0, 0.0]])\n    x = F @ x + B @ u",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "observation_model",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "def observation_model(x):\n    H = np.array([\n        [1, 0, 0, 0],\n        [0, 1, 0, 0]\n    ])\n    z = H @ x\n    return z\ndef jacob_f(x, u):\n    \"\"\"\n    Jacobian of Motion Model",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "jacob_f",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "def jacob_f(x, u):\n    \"\"\"\n    Jacobian of Motion Model\n    motion model\n    x_{t+1} = x_t+v*dt*cos(yaw)\n    y_{t+1} = y_t+v*dt*sin(yaw)\n    yaw_{t+1} = yaw_t+omega*dt\n    v_{t+1} = v{t}\n    so\n    dx/dyaw = -v*dt*sin(yaw)",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "jacob_h",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "def jacob_h():\n    # Jacobian of Observation Model\n    jH = np.array([\n        [1, 0, 0, 0],\n        [0, 1, 0, 0]\n    ])\n    return jH\ndef ekf_estimation(xEst, PEst, z, u):\n    #  Predict\n    xPred = motion_model(xEst, u)",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "ekf_estimation",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "def ekf_estimation(xEst, PEst, z, u):\n    #  Predict\n    xPred = motion_model(xEst, u)\n    jF = jacob_f(xEst, u)\n    PPred = jF @ PEst @ jF.T + Q\n    #  Update\n    jH = jacob_h()\n    zPred = observation_model(xPred)\n    y = z - zPred\n    S = jH @ PPred @ jH.T + R",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "def main():\n    print(__file__ + \" start!!\")\n    time = 0.0\n    # State Vector [x y yaw v]'\n    xEst = np.zeros((4, 1))\n    xTrue = np.zeros((4, 1))\n    PEst = np.eye(4)\n    xDR = np.zeros((4, 1))  # Dead reckoning\n    # history\n    hxEst = xEst",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "Q",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "Q = np.diag([\n    0.1,  # variance of location on x-axis\n    0.1,  # variance of location on y-axis\n    np.deg2rad(1.0),  # variance of yaw angle\n    1.0  # variance of velocity\n]) ** 2  # predict state covariance\nR = np.diag([1.0, 1.0]) ** 2  # Observation x,y position covariance\n#  Simulation parameter\nINPUT_NOISE = np.diag([1.0, np.deg2rad(30.0)]) ** 2\nGPS_NOISE = np.diag([0.5, 0.5]) ** 2",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "R",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "R = np.diag([1.0, 1.0]) ** 2  # Observation x,y position covariance\n#  Simulation parameter\nINPUT_NOISE = np.diag([1.0, np.deg2rad(30.0)]) ** 2\nGPS_NOISE = np.diag([0.5, 0.5]) ** 2\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nshow_animation = True\ndef calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "INPUT_NOISE",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "INPUT_NOISE = np.diag([1.0, np.deg2rad(30.0)]) ** 2\nGPS_NOISE = np.diag([0.5, 0.5]) ** 2\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nshow_animation = True\ndef calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]\n    u = np.array([[v], [yawrate]])\n    return u",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "GPS_NOISE",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "GPS_NOISE = np.diag([0.5, 0.5]) ** 2\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nshow_animation = True\ndef calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]\n    u = np.array([[v], [yawrate]])\n    return u\ndef observation(xTrue, xd, u):",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "DT",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "DT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nshow_animation = True\ndef calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]\n    u = np.array([[v], [yawrate]])\n    return u\ndef observation(xTrue, xd, u):\n    xTrue = motion_model(xTrue, u)",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "SIM_TIME",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "SIM_TIME = 50.0  # simulation time [s]\nshow_animation = True\ndef calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]\n    u = np.array([[v], [yawrate]])\n    return u\ndef observation(xTrue, xd, u):\n    xTrue = motion_model(xTrue, u)\n    # add noise to gps x-y",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "Localization.extended_kalman_filter.extended_kalman_filter",
        "description": "Localization.extended_kalman_filter.extended_kalman_filter",
        "peekOfCode": "show_animation = True\ndef calc_input():\n    v = 1.0  # [m/s]\n    yawrate = 0.1  # [rad/s]\n    u = np.array([[v], [yawrate]])\n    return u\ndef observation(xTrue, xd, u):\n    xTrue = motion_model(xTrue, u)\n    # add noise to gps x-y\n    z = observation_model(xTrue) + GPS_NOISE @ np.random.randn(2, 1)",
        "detail": "Localization.extended_kalman_filter.extended_kalman_filter",
        "documentation": {}
    },
    {
        "label": "circle_fitting",
        "kind": 2,
        "importPath": "Mapping.circle_fitting.circle_fitting",
        "description": "Mapping.circle_fitting.circle_fitting",
        "peekOfCode": "def circle_fitting(x, y):\n    \"\"\"\n    Circle Fitting with least squared\n        input: point x-y positions\n        output  cxe x center position\n                cye y center position\n                re  radius of circle\n                error: prediction error\n    \"\"\"\n    sumx = sum(x)",
        "detail": "Mapping.circle_fitting.circle_fitting",
        "documentation": {}
    },
    {
        "label": "get_sample_points",
        "kind": 2,
        "importPath": "Mapping.circle_fitting.circle_fitting",
        "description": "Mapping.circle_fitting.circle_fitting",
        "peekOfCode": "def get_sample_points(cx, cy, cr, angle_reso):\n    x, y, angle, r = [], [], [], []\n    # points sampling\n    for theta in np.arange(0.0, 2.0 * math.pi, angle_reso):\n        nx = cx + cr * math.cos(theta)\n        ny = cy + cr * math.sin(theta)\n        nangle = math.atan2(ny, nx)\n        nr = math.hypot(nx, ny) * random.uniform(0.95, 1.05)\n        x.append(nx)\n        y.append(ny)",
        "detail": "Mapping.circle_fitting.circle_fitting",
        "documentation": {}
    },
    {
        "label": "ray_casting_filter",
        "kind": 2,
        "importPath": "Mapping.circle_fitting.circle_fitting",
        "description": "Mapping.circle_fitting.circle_fitting",
        "peekOfCode": "def ray_casting_filter(xl, yl, thetal, rangel, angle_reso):\n    rx, ry = [], []\n    rangedb = [float(\"inf\") for _ in range(\n        int(math.floor((math.pi * 2.0) / angle_reso)) + 1)]\n    for i, _ in enumerate(thetal):\n        angleid = math.floor(thetal[i] / angle_reso)\n        if rangedb[angleid] > rangel[i]:\n            rangedb[angleid] = rangel[i]\n    for i, _ in enumerate(rangedb):\n        t = i * angle_reso",
        "detail": "Mapping.circle_fitting.circle_fitting",
        "documentation": {}
    },
    {
        "label": "plot_circle",
        "kind": 2,
        "importPath": "Mapping.circle_fitting.circle_fitting",
        "description": "Mapping.circle_fitting.circle_fitting",
        "peekOfCode": "def plot_circle(x, y, size, color=\"-b\"):  # pragma: no cover\n    deg = list(range(0, 360, 5))\n    deg.append(0)\n    xl = [x + size * math.cos(np.deg2rad(d)) for d in deg]\n    yl = [y + size * math.sin(np.deg2rad(d)) for d in deg]\n    plt.plot(xl, yl, color)\ndef main():\n    # simulation parameters\n    simtime = 15.0  # simulation time\n    dt = 1.0  # time tick",
        "detail": "Mapping.circle_fitting.circle_fitting",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Mapping.circle_fitting.circle_fitting",
        "description": "Mapping.circle_fitting.circle_fitting",
        "peekOfCode": "def main():\n    # simulation parameters\n    simtime = 15.0  # simulation time\n    dt = 1.0  # time tick\n    cx = -2.0  # initial x position of obstacle\n    cy = -8.0  # initial y position of obstacle\n    cr = 1.0  # obstacle radious\n    theta = np.deg2rad(30.0)  # obstacle moving direction\n    angle_reso = np.deg2rad(3.0)  # sensor angle resolution\n    time = 0.0",
        "detail": "Mapping.circle_fitting.circle_fitting",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "Mapping.circle_fitting.circle_fitting",
        "description": "Mapping.circle_fitting.circle_fitting",
        "peekOfCode": "show_animation = True\ndef circle_fitting(x, y):\n    \"\"\"\n    Circle Fitting with least squared\n        input: point x-y positions\n        output  cxe x center position\n                cye y center position\n                re  radius of circle\n                error: prediction error\n    \"\"\"",
        "detail": "Mapping.circle_fitting.circle_fitting",
        "documentation": {}
    },
    {
        "label": "generate_gaussian_grid_map",
        "kind": 2,
        "importPath": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "description": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "peekOfCode": "def generate_gaussian_grid_map(ox, oy, xyreso, std):\n    minx, miny, maxx, maxy, xw, yw = calc_grid_map_config(ox, oy, xyreso)\n    gmap = [[0.0 for i in range(yw)] for i in range(xw)]\n    for ix in range(xw):\n        for iy in range(yw):\n            x = ix * xyreso + minx\n            y = iy * xyreso + miny\n            # Search minimum distance\n            mindis = float(\"inf\")\n            for (iox, ioy) in zip(ox, oy):",
        "detail": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "documentation": {}
    },
    {
        "label": "calc_grid_map_config",
        "kind": 2,
        "importPath": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "description": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "peekOfCode": "def calc_grid_map_config(ox, oy, xyreso):\n    minx = round(min(ox) - EXTEND_AREA / 2.0)\n    miny = round(min(oy) - EXTEND_AREA / 2.0)\n    maxx = round(max(ox) + EXTEND_AREA / 2.0)\n    maxy = round(max(oy) + EXTEND_AREA / 2.0)\n    xw = int(round((maxx - minx) / xyreso))\n    yw = int(round((maxy - miny) / xyreso))\n    return minx, miny, maxx, maxy, xw, yw\ndef draw_heatmap(data, minx, maxx, miny, maxy, xyreso):\n    x, y = np.mgrid[slice(minx - xyreso / 2.0, maxx + xyreso / 2.0, xyreso),",
        "detail": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "documentation": {}
    },
    {
        "label": "draw_heatmap",
        "kind": 2,
        "importPath": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "description": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "peekOfCode": "def draw_heatmap(data, minx, maxx, miny, maxy, xyreso):\n    x, y = np.mgrid[slice(minx - xyreso / 2.0, maxx + xyreso / 2.0, xyreso),\n                    slice(miny - xyreso / 2.0, maxy + xyreso / 2.0, xyreso)]\n    plt.pcolor(x, y, data, vmax=1.0, cmap=plt.cm.Blues)\n    plt.axis(\"equal\")\ndef main():\n    print(__file__ + \" start!!\")\n    xyreso = 0.5  # xy grid resolution\n    STD = 5.0  # standard diviation for gaussian distribution\n    for i in range(5):",
        "detail": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "description": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "peekOfCode": "def main():\n    print(__file__ + \" start!!\")\n    xyreso = 0.5  # xy grid resolution\n    STD = 5.0  # standard diviation for gaussian distribution\n    for i in range(5):\n        ox = (np.random.rand(4) - 0.5) * 10.0\n        oy = (np.random.rand(4) - 0.5) * 10.0\n        gmap, minx, maxx, miny, maxy = generate_gaussian_grid_map(\n            ox, oy, xyreso, STD)\n        if show_animation:  # pragma: no cover",
        "detail": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "documentation": {}
    },
    {
        "label": "EXTEND_AREA",
        "kind": 5,
        "importPath": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "description": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "peekOfCode": "EXTEND_AREA = 10.0  # [m] grid map extention length\nshow_animation = True\ndef generate_gaussian_grid_map(ox, oy, xyreso, std):\n    minx, miny, maxx, maxy, xw, yw = calc_grid_map_config(ox, oy, xyreso)\n    gmap = [[0.0 for i in range(yw)] for i in range(xw)]\n    for ix in range(xw):\n        for iy in range(yw):\n            x = ix * xyreso + minx\n            y = iy * xyreso + miny\n            # Search minimum distance",
        "detail": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "description": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "peekOfCode": "show_animation = True\ndef generate_gaussian_grid_map(ox, oy, xyreso, std):\n    minx, miny, maxx, maxy, xw, yw = calc_grid_map_config(ox, oy, xyreso)\n    gmap = [[0.0 for i in range(yw)] for i in range(xw)]\n    for ix in range(xw):\n        for iy in range(yw):\n            x = ix * xyreso + minx\n            y = iy * xyreso + miny\n            # Search minimum distance\n            mindis = float(\"inf\")",
        "detail": "Mapping.gaussian_grid_map.gaussian_grid_map",
        "documentation": {}
    },
    {
        "label": "FloatGrid",
        "kind": 6,
        "importPath": "Mapping.grid_map_lib.grid_map_lib",
        "description": "Mapping.grid_map_lib.grid_map_lib",
        "peekOfCode": "class FloatGrid:\n    def __init__(self, init_val=0.0):\n        self.data = init_val\n    def get_float_data(self):\n        return self.data\n    def __eq__(self, other):\n        if not isinstance(other, FloatGrid):\n            return NotImplemented\n        return self.get_float_data() == other.get_float_data()\n    def __lt__(self, other):",
        "detail": "Mapping.grid_map_lib.grid_map_lib",
        "documentation": {}
    },
    {
        "label": "GridMap",
        "kind": 6,
        "importPath": "Mapping.grid_map_lib.grid_map_lib",
        "description": "Mapping.grid_map_lib.grid_map_lib",
        "peekOfCode": "class GridMap:\n    \"\"\"\n    GridMap class\n    \"\"\"\n    def __init__(self, width, height, resolution,\n                 center_x, center_y, init_val=FloatGrid(0.0)):\n        \"\"\"__init__\n        :param width: number of grid for width\n        :param height: number of grid for height\n        :param resolution: grid resolution [m]",
        "detail": "Mapping.grid_map_lib.grid_map_lib",
        "documentation": {}
    },
    {
        "label": "polygon_set_demo",
        "kind": 2,
        "importPath": "Mapping.grid_map_lib.grid_map_lib",
        "description": "Mapping.grid_map_lib.grid_map_lib",
        "peekOfCode": "def polygon_set_demo():\n    ox = [0.0, 4.35, 20.0, 50.0, 100.0, 130.0, 40.0]\n    oy = [0.0, -4.15, -20.0, 0.0, 30.0, 60.0, 80.0]\n    grid_map = GridMap(600, 290, 0.7, 60.0, 30.5)\n    grid_map.set_value_from_polygon(ox, oy, FloatGrid(1.0), inside=False)\n    grid_map.plot_grid_map()\n    plt.axis(\"equal\")\n    plt.grid(True)\ndef position_set_demo():\n    grid_map = GridMap(100, 120, 0.5, 10.0, -0.5)",
        "detail": "Mapping.grid_map_lib.grid_map_lib",
        "documentation": {}
    },
    {
        "label": "position_set_demo",
        "kind": 2,
        "importPath": "Mapping.grid_map_lib.grid_map_lib",
        "description": "Mapping.grid_map_lib.grid_map_lib",
        "peekOfCode": "def position_set_demo():\n    grid_map = GridMap(100, 120, 0.5, 10.0, -0.5)\n    grid_map.set_value_from_xy_pos(10.1, -1.1, FloatGrid(1.0))\n    grid_map.set_value_from_xy_pos(10.1, -0.1, FloatGrid(1.0))\n    grid_map.set_value_from_xy_pos(10.1, 1.1, FloatGrid(1.0))\n    grid_map.set_value_from_xy_pos(11.1, 0.1, FloatGrid(1.0))\n    grid_map.set_value_from_xy_pos(10.1, 0.1, FloatGrid(1.0))\n    grid_map.set_value_from_xy_pos(9.1, 0.1, FloatGrid(1.0))\n    grid_map.plot_grid_map()\n    plt.axis(\"equal\")",
        "detail": "Mapping.grid_map_lib.grid_map_lib",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Mapping.grid_map_lib.grid_map_lib",
        "description": "Mapping.grid_map_lib.grid_map_lib",
        "peekOfCode": "def main():\n    print(\"start!!\")\n    position_set_demo()\n    polygon_set_demo()\n    plt.show()\n    print(\"done!!\")\nif __name__ == '__main__':\n    main()",
        "detail": "Mapping.grid_map_lib.grid_map_lib",
        "documentation": {}
    },
    {
        "label": "Clusters",
        "kind": 6,
        "importPath": "Mapping.kmeans_clustering.kmeans_clustering",
        "description": "Mapping.kmeans_clustering.kmeans_clustering",
        "peekOfCode": "class Clusters:\n    def __init__(self, x, y, n_label):\n        self.x = x\n        self.y = y\n        self.n_data = len(self.x)\n        self.n_label = n_label\n        self.labels = [random.randint(0, n_label - 1)\n                       for _ in range(self.n_data)]\n        self.center_x = [0.0 for _ in range(n_label)]\n        self.center_y = [0.0 for _ in range(n_label)]",
        "detail": "Mapping.kmeans_clustering.kmeans_clustering",
        "documentation": {}
    },
    {
        "label": "kmeans_clustering",
        "kind": 2,
        "importPath": "Mapping.kmeans_clustering.kmeans_clustering",
        "description": "Mapping.kmeans_clustering.kmeans_clustering",
        "peekOfCode": "def kmeans_clustering(rx, ry, nc):\n    clusters = Clusters(rx, ry, nc)\n    clusters.calc_centroid()\n    pre_cost = float(\"inf\")\n    for loop in range(MAX_LOOP):\n        print(\"loop:\", loop)\n        cost = clusters.update_clusters()\n        clusters.calc_centroid()\n        d_cost = abs(cost - pre_cost)\n        if d_cost < DCOST_TH:",
        "detail": "Mapping.kmeans_clustering.kmeans_clustering",
        "documentation": {}
    },
    {
        "label": "calc_raw_data",
        "kind": 2,
        "importPath": "Mapping.kmeans_clustering.kmeans_clustering",
        "description": "Mapping.kmeans_clustering.kmeans_clustering",
        "peekOfCode": "def calc_raw_data(cx, cy, n_points, rand_d):\n    rx, ry = [], []\n    for (icx, icy) in zip(cx, cy):\n        for _ in range(n_points):\n            rx.append(icx + rand_d * (random.random() - 0.5))\n            ry.append(icy + rand_d * (random.random() - 0.5))\n    return rx, ry\ndef update_positions(cx, cy):\n    # object moving parameters\n    DX1 = 0.4",
        "detail": "Mapping.kmeans_clustering.kmeans_clustering",
        "documentation": {}
    },
    {
        "label": "update_positions",
        "kind": 2,
        "importPath": "Mapping.kmeans_clustering.kmeans_clustering",
        "description": "Mapping.kmeans_clustering.kmeans_clustering",
        "peekOfCode": "def update_positions(cx, cy):\n    # object moving parameters\n    DX1 = 0.4\n    DY1 = 0.5\n    DX2 = -0.3\n    DY2 = -0.5\n    cx[0] += DX1\n    cy[0] += DY1\n    cx[1] += DX2\n    cy[1] += DY2",
        "detail": "Mapping.kmeans_clustering.kmeans_clustering",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Mapping.kmeans_clustering.kmeans_clustering",
        "description": "Mapping.kmeans_clustering.kmeans_clustering",
        "peekOfCode": "def main():\n    print(__file__ + \" start!!\")\n    cx = [0.0, 8.0]\n    cy = [0.0, 8.0]\n    n_points = 10\n    rand_d = 3.0\n    n_cluster = 2\n    sim_time = 15.0\n    dt = 1.0\n    time = 0.0",
        "detail": "Mapping.kmeans_clustering.kmeans_clustering",
        "documentation": {}
    },
    {
        "label": "MAX_LOOP",
        "kind": 5,
        "importPath": "Mapping.kmeans_clustering.kmeans_clustering",
        "description": "Mapping.kmeans_clustering.kmeans_clustering",
        "peekOfCode": "MAX_LOOP = 10\nDCOST_TH = 0.1\nshow_animation = True\ndef kmeans_clustering(rx, ry, nc):\n    clusters = Clusters(rx, ry, nc)\n    clusters.calc_centroid()\n    pre_cost = float(\"inf\")\n    for loop in range(MAX_LOOP):\n        print(\"loop:\", loop)\n        cost = clusters.update_clusters()",
        "detail": "Mapping.kmeans_clustering.kmeans_clustering",
        "documentation": {}
    },
    {
        "label": "DCOST_TH",
        "kind": 5,
        "importPath": "Mapping.kmeans_clustering.kmeans_clustering",
        "description": "Mapping.kmeans_clustering.kmeans_clustering",
        "peekOfCode": "DCOST_TH = 0.1\nshow_animation = True\ndef kmeans_clustering(rx, ry, nc):\n    clusters = Clusters(rx, ry, nc)\n    clusters.calc_centroid()\n    pre_cost = float(\"inf\")\n    for loop in range(MAX_LOOP):\n        print(\"loop:\", loop)\n        cost = clusters.update_clusters()\n        clusters.calc_centroid()",
        "detail": "Mapping.kmeans_clustering.kmeans_clustering",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "Mapping.kmeans_clustering.kmeans_clustering",
        "description": "Mapping.kmeans_clustering.kmeans_clustering",
        "peekOfCode": "show_animation = True\ndef kmeans_clustering(rx, ry, nc):\n    clusters = Clusters(rx, ry, nc)\n    clusters.calc_centroid()\n    pre_cost = float(\"inf\")\n    for loop in range(MAX_LOOP):\n        print(\"loop:\", loop)\n        cost = clusters.update_clusters()\n        clusters.calc_centroid()\n        d_cost = abs(cost - pre_cost)",
        "detail": "Mapping.kmeans_clustering.kmeans_clustering",
        "documentation": {}
    },
    {
        "label": "file_read",
        "kind": 2,
        "importPath": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "description": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "peekOfCode": "def file_read(f):\n    \"\"\"\n    Reading LIDAR laser beams (angles and corresponding distance data)\n    \"\"\"\n    with open(f) as data:\n        measures = [line.split(\",\") for line in data]\n    angles = []\n    distances = []\n    for measure in measures:\n        angles.append(float(measure[0]))",
        "detail": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "documentation": {}
    },
    {
        "label": "bresenham",
        "kind": 2,
        "importPath": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "description": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "peekOfCode": "def bresenham(start, end):\n    \"\"\"\n    Implementation of Bresenham's line drawing algorithm\n    See en.wikipedia.org/wiki/Bresenham's_line_algorithm\n    Bresenham's Line Algorithm\n    Produces a np.array from start and end (original from roguebasin.com)\n    >>> points1 = bresenham((4, 4), (6, 10))\n    >>> print(points1)\n    np.array([[4,4], [4,5], [5,6], [5,7], [5,8], [6,9], [6,10]])\n    \"\"\"",
        "detail": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "documentation": {}
    },
    {
        "label": "calc_grid_map_config",
        "kind": 2,
        "importPath": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "description": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "peekOfCode": "def calc_grid_map_config(ox, oy, xy_resolution):\n    \"\"\"\n    Calculates the size, and the maximum distances according to the the\n    measurement center\n    \"\"\"\n    min_x = round(min(ox) - EXTEND_AREA / 2.0)\n    min_y = round(min(oy) - EXTEND_AREA / 2.0)\n    max_x = round(max(ox) + EXTEND_AREA / 2.0)\n    max_y = round(max(oy) + EXTEND_AREA / 2.0)\n    xw = int(round((max_x - min_x) / xy_resolution))",
        "detail": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "documentation": {}
    },
    {
        "label": "atan_zero_to_twopi",
        "kind": 2,
        "importPath": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "description": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "peekOfCode": "def atan_zero_to_twopi(y, x):\n    angle = math.atan2(y, x)\n    if angle < 0.0:\n        angle += math.pi * 2.0\n    return angle\ndef init_flood_fill(center_point, obstacle_points, xy_points, min_coord,\n                    xy_resolution):\n    \"\"\"\n    center_point: center point\n    obstacle_points: detected obstacles points (x,y)",
        "detail": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "documentation": {}
    },
    {
        "label": "init_flood_fill",
        "kind": 2,
        "importPath": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "description": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "peekOfCode": "def init_flood_fill(center_point, obstacle_points, xy_points, min_coord,\n                    xy_resolution):\n    \"\"\"\n    center_point: center point\n    obstacle_points: detected obstacles points (x,y)\n    xy_points: (x,y) point pairs\n    \"\"\"\n    center_x, center_y = center_point\n    prev_ix, prev_iy = center_x - 1, center_y\n    ox, oy = obstacle_points",
        "detail": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "documentation": {}
    },
    {
        "label": "flood_fill",
        "kind": 2,
        "importPath": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "description": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "peekOfCode": "def flood_fill(center_point, occupancy_map):\n    \"\"\"\n    center_point: starting point (x,y) of fill\n    occupancy_map: occupancy map generated from Bresenham ray-tracing\n    \"\"\"\n    # Fill empty areas with queue method\n    sx, sy = occupancy_map.shape\n    fringe = deque()\n    fringe.appendleft(center_point)\n    while fringe:",
        "detail": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "documentation": {}
    },
    {
        "label": "generate_ray_casting_grid_map",
        "kind": 2,
        "importPath": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "description": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "peekOfCode": "def generate_ray_casting_grid_map(ox, oy, xy_resolution, breshen=True):\n    \"\"\"\n    The breshen boolean tells if it's computed with bresenham ray casting\n    (True) or with flood fill (False)\n    \"\"\"\n    min_x, min_y, max_x, max_y, x_w, y_w = calc_grid_map_config(\n        ox, oy, xy_resolution)\n    # default 0.5 -- [[0.5 for i in range(y_w)] for i in range(x_w)]\n    occupancy_map = np.ones((x_w, y_w)) / 2\n    center_x = int(",
        "detail": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "description": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "peekOfCode": "def main():\n    \"\"\"\n    Example usage\n    \"\"\"\n    print(__file__, \"start\")\n    xy_resolution = 0.02  # x-y grid resolution\n    ang, dist = file_read(\"lidar01.csv\")\n    ox = np.sin(ang) * dist\n    oy = np.cos(ang) * dist\n    occupancy_map, min_x, max_x, min_y, max_y, xy_resolution = \\",
        "detail": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "documentation": {}
    },
    {
        "label": "EXTEND_AREA",
        "kind": 5,
        "importPath": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "description": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "peekOfCode": "EXTEND_AREA = 1.0\ndef file_read(f):\n    \"\"\"\n    Reading LIDAR laser beams (angles and corresponding distance data)\n    \"\"\"\n    with open(f) as data:\n        measures = [line.split(\",\") for line in data]\n    angles = []\n    distances = []\n    for measure in measures:",
        "detail": "Mapping.lidar_to_grid_map.lidar_to_grid_map",
        "documentation": {}
    },
    {
        "label": "calc_normal_vector",
        "kind": 2,
        "importPath": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "description": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "peekOfCode": "def calc_normal_vector(p1, p2, p3):\n    \"\"\"Calculate normal vector of triangle\n    Parameters\n    ----------\n    p1 : np.array\n        3D point\n    p2 : np.array\n        3D point\n    p3 : np.array\n        3D point",
        "detail": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "documentation": {}
    },
    {
        "label": "sample_3d_points_from_a_plane",
        "kind": 2,
        "importPath": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "description": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "peekOfCode": "def sample_3d_points_from_a_plane(num_samples, normal):\n    points_2d = np.random.normal(size=(num_samples, 2))  # 2D points on a plane\n    d = 0\n    for i in range(len(points_2d)):\n        point_3d = np.append(points_2d[i], 0)\n        d += normal @ point_3d\n    d /= len(points_2d)\n    points_3d = np.zeros((len(points_2d), 3))\n    for i in range(len(points_2d)):\n        point_2d = np.append(points_2d[i], 0)",
        "detail": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "documentation": {}
    },
    {
        "label": "distance_to_plane",
        "kind": 2,
        "importPath": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "description": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "peekOfCode": "def distance_to_plane(point, normal, origin):\n    dot_product = np.dot(normal, point) - np.dot(normal, origin)\n    if np.isclose(dot_product, 0):\n        return 0.0\n    else:\n        distance = abs(dot_product) / np.linalg.norm(normal)\n        return distance\ndef ransac_normal_vector_estimation(points_3d, inlier_radio_th=0.7,\n                                    inlier_dist=0.1, p=0.99):\n    \"\"\"",
        "detail": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "documentation": {}
    },
    {
        "label": "ransac_normal_vector_estimation",
        "kind": 2,
        "importPath": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "description": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "peekOfCode": "def ransac_normal_vector_estimation(points_3d, inlier_radio_th=0.7,\n                                    inlier_dist=0.1, p=0.99):\n    \"\"\"\n    RANSAC based normal vector estimation\n    Parameters\n    ----------\n    points_3d : np.array\n        3D points (N, 3)\n    inlier_radio_th : float\n        Inlier ratio threshold. If inlier ratio is larger than this value,",
        "detail": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "documentation": {}
    },
    {
        "label": "main1",
        "kind": 2,
        "importPath": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "description": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "peekOfCode": "def main1():\n    p1 = np.array([0.0, 0.0, 1.0])\n    p2 = np.array([1.0, 1.0, 0.0])\n    p3 = np.array([0.0, 1.0, 0.0])\n    center = np.mean([p1, p2, p3], axis=0)\n    normal_vector = calc_normal_vector(p1, p2, p3)\n    print(f\"{center=}\")\n    print(f\"{normal_vector=}\")\n    if show_animation:\n        fig = plt.figure()",
        "detail": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "documentation": {}
    },
    {
        "label": "main2",
        "kind": 2,
        "importPath": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "description": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "peekOfCode": "def main2(rng=None):\n    true_normal = np.array([0, 1, 1])\n    true_normal = true_normal / np.linalg.norm(true_normal)\n    num_samples = 100\n    noise_scale = 0.1\n    points_3d = sample_3d_points_from_a_plane(num_samples, true_normal)\n    # add random noise\n    points_3d += np.random.normal(size=points_3d.shape, scale=noise_scale)\n    print(f\"{points_3d.shape=}\")\n    center, estimated_normal = ransac_normal_vector_estimation(",
        "detail": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "description": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "peekOfCode": "show_animation = True\ndef calc_normal_vector(p1, p2, p3):\n    \"\"\"Calculate normal vector of triangle\n    Parameters\n    ----------\n    p1 : np.array\n        3D point\n    p2 : np.array\n        3D point\n    p3 : np.array",
        "detail": "Mapping.normal_vector_estimation.normal_vector_estimation",
        "documentation": {}
    },
    {
        "label": "voxel_point_sampling",
        "kind": 2,
        "importPath": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "description": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "peekOfCode": "def voxel_point_sampling(original_points: npt.NDArray, voxel_size: float):\n    \"\"\"\n    Voxel Point Sampling function.\n    This function sample N-dimensional points with voxel grid.\n    Points in a same voxel grid will be merged by mean operation for sampling.\n    Parameters\n    ----------\n    original_points :  (M, N) N-dimensional points for sampling.\n                        The number of points is M.\n    voxel_size : voxel grid size",
        "detail": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "documentation": {}
    },
    {
        "label": "farthest_point_sampling",
        "kind": 2,
        "importPath": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "description": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "peekOfCode": "def farthest_point_sampling(orig_points: npt.NDArray,\n                            n_points: int, seed: int):\n    \"\"\"\n    Farthest point sampling function\n    This function sample N-dimensional points with the farthest point policy.\n    Parameters\n    ----------\n    orig_points :  (M, N) N-dimensional points for sampling.\n                    The number of points is M.\n    n_points : number of points for sampling",
        "detail": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "documentation": {}
    },
    {
        "label": "poisson_disk_sampling",
        "kind": 2,
        "importPath": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "description": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "peekOfCode": "def poisson_disk_sampling(orig_points: npt.NDArray, n_points: int,\n                          min_distance: float, seed: int, MAX_ITER=1000):\n    \"\"\"\n    Poisson disk sampling function\n    This function sample N-dimensional points randomly until the number of\n    points keeping minimum distance between selected points.\n    Parameters\n    ----------\n    orig_points :  (M, N) N-dimensional points for sampling.\n                    The number of points is M.",
        "detail": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "documentation": {}
    },
    {
        "label": "plot_sampled_points",
        "kind": 2,
        "importPath": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "description": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "peekOfCode": "def plot_sampled_points(original_points, sampled_points, method_name):\n    fig = plt.figure()\n    ax = fig.add_subplot(projection='3d')\n    ax.scatter(original_points[:, 0], original_points[:, 1],\n               original_points[:, 2], marker=\".\", label=\"Original points\")\n    ax.scatter(sampled_points[:, 0], sampled_points[:, 1],\n               sampled_points[:, 2], marker=\"o\",\n               label=\"Filtered points\")\n    plt.legend()\n    plt.title(method_name)",
        "detail": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "description": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "peekOfCode": "def main():\n    n_points = 1000\n    seed = 1234\n    rng = np.random.default_rng(seed)\n    x = rng.normal(0.0, 10.0, n_points)\n    y = rng.normal(0.0, 1.0, n_points)\n    z = rng.normal(0.0, 10.0, n_points)\n    original_points = np.vstack((x, y, z)).T\n    print(f\"{original_points.shape=}\")\n    print(\"Voxel point sampling\")",
        "detail": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "documentation": {}
    },
    {
        "label": "do_plot",
        "kind": 5,
        "importPath": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "description": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "peekOfCode": "do_plot = True\ndef voxel_point_sampling(original_points: npt.NDArray, voxel_size: float):\n    \"\"\"\n    Voxel Point Sampling function.\n    This function sample N-dimensional points with voxel grid.\n    Points in a same voxel grid will be merged by mean operation for sampling.\n    Parameters\n    ----------\n    original_points :  (M, N) N-dimensional points for sampling.\n                        The number of points is M.",
        "detail": "Mapping.point_cloud_sampling.point_cloud_sampling",
        "documentation": {}
    },
    {
        "label": "precastDB",
        "kind": 6,
        "importPath": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "description": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "peekOfCode": "class precastDB:\n    def __init__(self):\n        self.px = 0.0\n        self.py = 0.0\n        self.d = 0.0\n        self.angle = 0.0\n        self.ix = 0\n        self.iy = 0\n    def __str__(self):\n        return str(self.px) + \",\" + str(self.py) + \",\" + str(self.d) + \",\" + str(self.angle)",
        "detail": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "documentation": {}
    },
    {
        "label": "calc_grid_map_config",
        "kind": 2,
        "importPath": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "description": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "peekOfCode": "def calc_grid_map_config(ox, oy, xyreso):\n    minx = round(min(ox) - EXTEND_AREA / 2.0)\n    miny = round(min(oy) - EXTEND_AREA / 2.0)\n    maxx = round(max(ox) + EXTEND_AREA / 2.0)\n    maxy = round(max(oy) + EXTEND_AREA / 2.0)\n    xw = int(round((maxx - minx) / xyreso))\n    yw = int(round((maxy - miny) / xyreso))\n    return minx, miny, maxx, maxy, xw, yw\nclass precastDB:\n    def __init__(self):",
        "detail": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "documentation": {}
    },
    {
        "label": "atan_zero_to_twopi",
        "kind": 2,
        "importPath": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "description": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "peekOfCode": "def atan_zero_to_twopi(y, x):\n    angle = math.atan2(y, x)\n    if angle < 0.0:\n        angle += math.pi * 2.0\n    return angle\ndef precasting(minx, miny, xw, yw, xyreso, yawreso):\n    precast = [[] for i in range(int(round((math.pi * 2.0) / yawreso)) + 1)]\n    for ix in range(xw):\n        for iy in range(yw):\n            px = ix * xyreso + minx",
        "detail": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "documentation": {}
    },
    {
        "label": "precasting",
        "kind": 2,
        "importPath": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "description": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "peekOfCode": "def precasting(minx, miny, xw, yw, xyreso, yawreso):\n    precast = [[] for i in range(int(round((math.pi * 2.0) / yawreso)) + 1)]\n    for ix in range(xw):\n        for iy in range(yw):\n            px = ix * xyreso + minx\n            py = iy * xyreso + miny\n            d = math.hypot(px, py)\n            angle = atan_zero_to_twopi(py, px)\n            angleid = int(math.floor(angle / yawreso))\n            pc = precastDB()",
        "detail": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "documentation": {}
    },
    {
        "label": "generate_ray_casting_grid_map",
        "kind": 2,
        "importPath": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "description": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "peekOfCode": "def generate_ray_casting_grid_map(ox, oy, xyreso, yawreso):\n    minx, miny, maxx, maxy, xw, yw = calc_grid_map_config(ox, oy, xyreso)\n    pmap = [[0.0 for i in range(yw)] for i in range(xw)]\n    precast = precasting(minx, miny, xw, yw, xyreso, yawreso)\n    for (x, y) in zip(ox, oy):\n        d = math.hypot(x, y)\n        angle = atan_zero_to_twopi(y, x)\n        angleid = int(math.floor(angle / yawreso))\n        gridlist = precast[angleid]\n        ix = int(round((x - minx) / xyreso))",
        "detail": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "documentation": {}
    },
    {
        "label": "draw_heatmap",
        "kind": 2,
        "importPath": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "description": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "peekOfCode": "def draw_heatmap(data, minx, maxx, miny, maxy, xyreso):\n    x, y = np.mgrid[slice(minx - xyreso / 2.0, maxx + xyreso / 2.0, xyreso),\n                    slice(miny - xyreso / 2.0, maxy + xyreso / 2.0, xyreso)]\n    plt.pcolor(x, y, data, vmax=1.0, cmap=plt.cm.Blues)\n    plt.axis(\"equal\")\ndef main():\n    print(__file__ + \" start!!\")\n    xyreso = 0.25  # x-y grid resolution [m]\n    yawreso = np.deg2rad(10.0)  # yaw angle resolution [rad]\n    for i in range(5):",
        "detail": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "description": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "peekOfCode": "def main():\n    print(__file__ + \" start!!\")\n    xyreso = 0.25  # x-y grid resolution [m]\n    yawreso = np.deg2rad(10.0)  # yaw angle resolution [rad]\n    for i in range(5):\n        ox = (np.random.rand(4) - 0.5) * 10.0\n        oy = (np.random.rand(4) - 0.5) * 10.0\n        pmap, minx, maxx, miny, maxy, xyreso = generate_ray_casting_grid_map(\n            ox, oy, xyreso, yawreso)\n        if show_animation:  # pragma: no cover",
        "detail": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "documentation": {}
    },
    {
        "label": "EXTEND_AREA",
        "kind": 5,
        "importPath": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "description": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "peekOfCode": "EXTEND_AREA = 10.0\nshow_animation = True\ndef calc_grid_map_config(ox, oy, xyreso):\n    minx = round(min(ox) - EXTEND_AREA / 2.0)\n    miny = round(min(oy) - EXTEND_AREA / 2.0)\n    maxx = round(max(ox) + EXTEND_AREA / 2.0)\n    maxy = round(max(oy) + EXTEND_AREA / 2.0)\n    xw = int(round((maxx - minx) / xyreso))\n    yw = int(round((maxy - miny) / xyreso))\n    return minx, miny, maxx, maxy, xw, yw",
        "detail": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "description": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "peekOfCode": "show_animation = True\ndef calc_grid_map_config(ox, oy, xyreso):\n    minx = round(min(ox) - EXTEND_AREA / 2.0)\n    miny = round(min(oy) - EXTEND_AREA / 2.0)\n    maxx = round(max(ox) + EXTEND_AREA / 2.0)\n    maxy = round(max(oy) + EXTEND_AREA / 2.0)\n    xw = int(round((maxx - minx) / xyreso))\n    yw = int(round((maxy - miny) / xyreso))\n    return minx, miny, maxx, maxy, xw, yw\nclass precastDB:",
        "detail": "Mapping.raycasting_grid_map.raycasting_grid_map",
        "documentation": {}
    },
    {
        "label": "LShapeFitting",
        "kind": 6,
        "importPath": "Mapping.rectangle_fitting.rectangle_fitting",
        "description": "Mapping.rectangle_fitting.rectangle_fitting",
        "peekOfCode": "class LShapeFitting:\n    \"\"\"\n    LShapeFitting class. You can use this class by initializing the class and\n    changing the parameters, and then calling the fitting method.\n    \"\"\"\n    class Criteria(Enum):\n        AREA = 1\n        CLOSENESS = 2\n        VARIANCE = 3\n    def __init__(self):",
        "detail": "Mapping.rectangle_fitting.rectangle_fitting",
        "documentation": {}
    },
    {
        "label": "RectangleData",
        "kind": 6,
        "importPath": "Mapping.rectangle_fitting.rectangle_fitting",
        "description": "Mapping.rectangle_fitting.rectangle_fitting",
        "peekOfCode": "class RectangleData:\n    def __init__(self):\n        self.a = [None] * 4\n        self.b = [None] * 4\n        self.c = [None] * 4\n        self.rect_c_x = [None] * 5\n        self.rect_c_y = [None] * 5\n    def plot(self):\n        self.calc_rect_contour()\n        plt.plot(self.rect_c_x, self.rect_c_y, \"-r\")",
        "detail": "Mapping.rectangle_fitting.rectangle_fitting",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Mapping.rectangle_fitting.rectangle_fitting",
        "description": "Mapping.rectangle_fitting.rectangle_fitting",
        "peekOfCode": "def main():\n    # simulation parameters\n    sim_time = 30.0  # simulation time\n    dt = 0.2  # time tick\n    angle_resolution = np.deg2rad(3.0)  # sensor angle resolution\n    v1 = VehicleSimulator(-10.0, 0.0, np.deg2rad(90.0),\n                          0.0, 50.0 / 3.6, 3.0, 5.0)\n    v2 = VehicleSimulator(20.0, 10.0, np.deg2rad(180.0),\n                          0.0, 50.0 / 3.6, 4.0, 10.0)\n    l_shape_fitting = LShapeFitting()",
        "detail": "Mapping.rectangle_fitting.rectangle_fitting",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "Mapping.rectangle_fitting.rectangle_fitting",
        "description": "Mapping.rectangle_fitting.rectangle_fitting",
        "peekOfCode": "show_animation = True\nclass LShapeFitting:\n    \"\"\"\n    LShapeFitting class. You can use this class by initializing the class and\n    changing the parameters, and then calling the fitting method.\n    \"\"\"\n    class Criteria(Enum):\n        AREA = 1\n        CLOSENESS = 2\n        VARIANCE = 3",
        "detail": "Mapping.rectangle_fitting.rectangle_fitting",
        "documentation": {}
    },
    {
        "label": "VehicleSimulator",
        "kind": 6,
        "importPath": "Mapping.rectangle_fitting.simulator",
        "description": "Mapping.rectangle_fitting.simulator",
        "peekOfCode": "class VehicleSimulator:\n    def __init__(self, i_x, i_y, i_yaw, i_v, max_v, w, L):\n        self.x = i_x\n        self.y = i_y\n        self.yaw = i_yaw\n        self.v = i_v\n        self.max_v = max_v\n        self.W = w\n        self.L = L\n        self._calc_vehicle_contour()",
        "detail": "Mapping.rectangle_fitting.simulator",
        "documentation": {}
    },
    {
        "label": "LidarSimulator",
        "kind": 6,
        "importPath": "Mapping.rectangle_fitting.simulator",
        "description": "Mapping.rectangle_fitting.simulator",
        "peekOfCode": "class LidarSimulator:\n    def __init__(self):\n        self.range_noise = 0.01\n    def get_observation_points(self, v_list, angle_resolution):\n        x, y, angle, r = [], [], [], []\n        # store all points\n        for v in v_list:\n            gx, gy = v.calc_global_contour()\n            for vx, vy in zip(gx, gy):\n                v_angle = math.atan2(vy, vx)",
        "detail": "Mapping.rectangle_fitting.simulator",
        "documentation": {}
    },
    {
        "label": "CubicSpline1D",
        "kind": 6,
        "importPath": "PathPlanning.CubicSpline.cubic_spline_planner",
        "description": "PathPlanning.CubicSpline.cubic_spline_planner",
        "peekOfCode": "class CubicSpline1D:\n    \"\"\"\n    1D Cubic Spline class\n    Parameters\n    ----------\n    x : list\n        x coordinates for data points. This x coordinates must be\n        sorted\n        in ascending order.\n    y : list",
        "detail": "PathPlanning.CubicSpline.cubic_spline_planner",
        "documentation": {}
    },
    {
        "label": "CubicSpline2D",
        "kind": 6,
        "importPath": "PathPlanning.CubicSpline.cubic_spline_planner",
        "description": "PathPlanning.CubicSpline.cubic_spline_planner",
        "peekOfCode": "class CubicSpline2D:\n    \"\"\"\n    Cubic CubicSpline2D class\n    Parameters\n    ----------\n    x : list\n        x coordinates for data points.\n    y : list\n        y coordinates for data points.\n    Examples",
        "detail": "PathPlanning.CubicSpline.cubic_spline_planner",
        "documentation": {}
    },
    {
        "label": "calc_spline_course",
        "kind": 2,
        "importPath": "PathPlanning.CubicSpline.cubic_spline_planner",
        "description": "PathPlanning.CubicSpline.cubic_spline_planner",
        "peekOfCode": "def calc_spline_course(x, y, ds=0.1):\n    sp = CubicSpline2D(x, y)\n    s = list(np.arange(0, sp.s[-1], ds))\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))",
        "detail": "PathPlanning.CubicSpline.cubic_spline_planner",
        "documentation": {}
    },
    {
        "label": "main_1d",
        "kind": 2,
        "importPath": "PathPlanning.CubicSpline.cubic_spline_planner",
        "description": "PathPlanning.CubicSpline.cubic_spline_planner",
        "peekOfCode": "def main_1d():\n    print(\"CubicSpline1D test\")\n    import matplotlib.pyplot as plt\n    x = np.arange(5)\n    y = [1.7, -6, 5, 6.5, 0.0]\n    sp = CubicSpline1D(x, y)\n    xi = np.linspace(0.0, 5.0)\n    plt.plot(x, y, \"xb\", label=\"Data points\")\n    plt.plot(xi, [sp.calc_position(x) for x in xi], \"r\",\n             label=\"Cubic spline interpolation\")",
        "detail": "PathPlanning.CubicSpline.cubic_spline_planner",
        "documentation": {}
    },
    {
        "label": "main_2d",
        "kind": 2,
        "importPath": "PathPlanning.CubicSpline.cubic_spline_planner",
        "description": "PathPlanning.CubicSpline.cubic_spline_planner",
        "peekOfCode": "def main_2d():  # pragma: no cover\n    print(\"CubicSpline1D 2D test\")\n    import matplotlib.pyplot as plt\n    x = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n    y = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n    ds = 0.1  # [m] distance of each interpolated points\n    sp = CubicSpline2D(x, y)\n    s = np.arange(0, sp.s[-1], ds)\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:",
        "detail": "PathPlanning.CubicSpline.cubic_spline_planner",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "PathPlanning.DStar.dstar",
        "description": "PathPlanning.DStar.dstar",
        "peekOfCode": "class State:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.parent = None\n        self.state = \".\"\n        self.t = \"new\"  # tag for state\n        self.h = 0\n        self.k = 0\n    def cost(self, state):",
        "detail": "PathPlanning.DStar.dstar",
        "documentation": {}
    },
    {
        "label": "Map",
        "kind": 6,
        "importPath": "PathPlanning.DStar.dstar",
        "description": "PathPlanning.DStar.dstar",
        "peekOfCode": "class Map:\n    def __init__(self, row, col):\n        self.row = row\n        self.col = col\n        self.map = self.init_map()\n    def init_map(self):\n        map_list = []\n        for i in range(self.row):\n            tmp = []\n            for j in range(self.col):",
        "detail": "PathPlanning.DStar.dstar",
        "documentation": {}
    },
    {
        "label": "Dstar",
        "kind": 6,
        "importPath": "PathPlanning.DStar.dstar",
        "description": "PathPlanning.DStar.dstar",
        "peekOfCode": "class Dstar:\n    def __init__(self, maps):\n        self.map = maps\n        self.open_list = set()\n    def process_state(self):\n        x = self.min_state()\n        if x is None:\n            return -1\n        k_old = self.get_kmin()\n        self.remove(x)",
        "detail": "PathPlanning.DStar.dstar",
        "documentation": {}
    },
    {
        "label": "AddNewObstacle",
        "kind": 2,
        "importPath": "PathPlanning.DStar.dstar",
        "description": "PathPlanning.DStar.dstar",
        "peekOfCode": "def AddNewObstacle(map:Map):\n    ox, oy = [], []\n    for i in range(5, 21):\n        ox.append(i)\n        oy.append(40)\n    map.set_obstacle([(i, j) for i, j in zip(ox, oy)])\n    if show_animation:\n        plt.pause(0.001)\n        plt.plot(ox, oy, \".g\")\ndef main():",
        "detail": "PathPlanning.DStar.dstar",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "PathPlanning.DStar.dstar",
        "description": "PathPlanning.DStar.dstar",
        "peekOfCode": "def main():\n    m = Map(100, 100)\n    ox, oy = [], []\n    for i in range(-10, 60):\n        ox.append(i)\n        oy.append(-10)\n    for i in range(-10, 60):\n        ox.append(60)\n        oy.append(i)\n    for i in range(-10, 61):",
        "detail": "PathPlanning.DStar.dstar",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "PathPlanning.DStar.dstar",
        "description": "PathPlanning.DStar.dstar",
        "peekOfCode": "show_animation = True\nclass State:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.parent = None\n        self.state = \".\"\n        self.t = \"new\"  # tag for state\n        self.h = 0\n        self.k = 0",
        "detail": "PathPlanning.DStar.dstar",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "PathPlanning.DStarLite.d_star_lite",
        "description": "PathPlanning.DStarLite.d_star_lite",
        "peekOfCode": "class Node:\n    def __init__(self, x: int = 0, y: int = 0, cost: float = 0.0):\n        self.x = x\n        self.y = y\n        self.cost = cost\ndef add_coordinates(node1: Node, node2: Node):\n    new_node = Node()\n    new_node.x = node1.x + node2.x\n    new_node.y = node1.y + node2.y\n    new_node.cost = node1.cost + node2.cost",
        "detail": "PathPlanning.DStarLite.d_star_lite",
        "documentation": {}
    },
    {
        "label": "DStarLite",
        "kind": 6,
        "importPath": "PathPlanning.DStarLite.d_star_lite",
        "description": "PathPlanning.DStarLite.d_star_lite",
        "peekOfCode": "class DStarLite:\n    # Please adjust the heuristic function (h) if you change the list of\n    # possible motions\n    motions = [\n        Node(1, 0, 1),\n        Node(0, 1, 1),\n        Node(-1, 0, 1),\n        Node(0, -1, 1),\n        Node(1, 1, math.sqrt(2)),\n        Node(1, -1, math.sqrt(2)),",
        "detail": "PathPlanning.DStarLite.d_star_lite",
        "documentation": {}
    },
    {
        "label": "add_coordinates",
        "kind": 2,
        "importPath": "PathPlanning.DStarLite.d_star_lite",
        "description": "PathPlanning.DStarLite.d_star_lite",
        "peekOfCode": "def add_coordinates(node1: Node, node2: Node):\n    new_node = Node()\n    new_node.x = node1.x + node2.x\n    new_node.y = node1.y + node2.y\n    new_node.cost = node1.cost + node2.cost\n    return new_node\ndef compare_coordinates(node1: Node, node2: Node):\n    return node1.x == node2.x and node1.y == node2.y\nclass DStarLite:\n    # Please adjust the heuristic function (h) if you change the list of",
        "detail": "PathPlanning.DStarLite.d_star_lite",
        "documentation": {}
    },
    {
        "label": "compare_coordinates",
        "kind": 2,
        "importPath": "PathPlanning.DStarLite.d_star_lite",
        "description": "PathPlanning.DStarLite.d_star_lite",
        "peekOfCode": "def compare_coordinates(node1: Node, node2: Node):\n    return node1.x == node2.x and node1.y == node2.y\nclass DStarLite:\n    # Please adjust the heuristic function (h) if you change the list of\n    # possible motions\n    motions = [\n        Node(1, 0, 1),\n        Node(0, 1, 1),\n        Node(-1, 0, 1),\n        Node(0, -1, 1),",
        "detail": "PathPlanning.DStarLite.d_star_lite",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "PathPlanning.DStarLite.d_star_lite",
        "description": "PathPlanning.DStarLite.d_star_lite",
        "peekOfCode": "def main():\n    # start and goal position\n    sx = 10  # [m]\n    sy = 10  # [m]\n    gx = 50  # [m]\n    gy = 50  # [m]\n    # set obstacle positions\n    ox, oy = [], []\n    for i in range(-10, 60):\n        ox.append(i)",
        "detail": "PathPlanning.DStarLite.d_star_lite",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "PathPlanning.DStarLite.d_star_lite",
        "description": "PathPlanning.DStarLite.d_star_lite",
        "peekOfCode": "show_animation = True\npause_time = 0.001\np_create_random_obstacle = 0\nclass Node:\n    def __init__(self, x: int = 0, y: int = 0, cost: float = 0.0):\n        self.x = x\n        self.y = y\n        self.cost = cost\ndef add_coordinates(node1: Node, node2: Node):\n    new_node = Node()",
        "detail": "PathPlanning.DStarLite.d_star_lite",
        "documentation": {}
    },
    {
        "label": "pause_time",
        "kind": 5,
        "importPath": "PathPlanning.DStarLite.d_star_lite",
        "description": "PathPlanning.DStarLite.d_star_lite",
        "peekOfCode": "pause_time = 0.001\np_create_random_obstacle = 0\nclass Node:\n    def __init__(self, x: int = 0, y: int = 0, cost: float = 0.0):\n        self.x = x\n        self.y = y\n        self.cost = cost\ndef add_coordinates(node1: Node, node2: Node):\n    new_node = Node()\n    new_node.x = node1.x + node2.x",
        "detail": "PathPlanning.DStarLite.d_star_lite",
        "documentation": {}
    },
    {
        "label": "p_create_random_obstacle",
        "kind": 5,
        "importPath": "PathPlanning.DStarLite.d_star_lite",
        "description": "PathPlanning.DStarLite.d_star_lite",
        "peekOfCode": "p_create_random_obstacle = 0\nclass Node:\n    def __init__(self, x: int = 0, y: int = 0, cost: float = 0.0):\n        self.x = x\n        self.y = y\n        self.cost = cost\ndef add_coordinates(node1: Node, node2: Node):\n    new_node = Node()\n    new_node.x = node1.x + node2.x\n    new_node.y = node1.y + node2.y",
        "detail": "PathPlanning.DStarLite.d_star_lite",
        "documentation": {}
    },
    {
        "label": "Dijkstra",
        "kind": 6,
        "importPath": "PathPlanning.Dijkstra.dijkstra",
        "description": "PathPlanning.Dijkstra.dijkstra",
        "peekOfCode": "class Dijkstra:\n    def __init__(self, ox, oy, resolution, robot_radius):\n        \"\"\"\n        Initialize map for a star planning\n        ox: x position list of Obstacles [m]\n        oy: y position list of Obstacles [m]\n        resolution: grid resolution [m]\n        rr: robot radius[m]\n        \"\"\"\n        self.min_x = None",
        "detail": "PathPlanning.Dijkstra.dijkstra",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "PathPlanning.Dijkstra.dijkstra",
        "description": "PathPlanning.Dijkstra.dijkstra",
        "peekOfCode": "def main():\n    print(__file__ + \" start!!\")\n    # start and goal position\n    sx = -5.0  # [m]\n    sy = -5.0  # [m]\n    gx = 50.0  # [m]\n    gy = 50.0  # [m]\n    grid_size = 2.0  # [m]\n    robot_radius = 1.0  # [m]\n    # set obstacle positions",
        "detail": "PathPlanning.Dijkstra.dijkstra",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "PathPlanning.Dijkstra.dijkstra",
        "description": "PathPlanning.Dijkstra.dijkstra",
        "peekOfCode": "show_animation = True\nclass Dijkstra:\n    def __init__(self, ox, oy, resolution, robot_radius):\n        \"\"\"\n        Initialize map for a star planning\n        ox: x position list of Obstacles [m]\n        oy: y position list of Obstacles [m]\n        resolution: grid resolution [m]\n        rr: robot radius[m]\n        \"\"\"",
        "detail": "PathPlanning.Dijkstra.dijkstra",
        "documentation": {}
    },
    {
        "label": "RobotType",
        "kind": 6,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "class RobotType(Enum):\n    circle = 0\n    rectangle = 1\nclass Config:\n    \"\"\"\n    simulation parameter class\n    \"\"\"\n    def __init__(self):\n        # robot parameter\n        self.max_speed = 1.0  # [m/s]",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "class Config:\n    \"\"\"\n    simulation parameter class\n    \"\"\"\n    def __init__(self):\n        # robot parameter\n        self.max_speed = 1.0  # [m/s]\n        self.min_speed = -0.5  # [m/s]\n        self.max_yaw_rate = 40.0 * math.pi / 180.0  # [rad/s]\n        self.max_accel = 0.2  # [m/ss]",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "dwa_control",
        "kind": 2,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "def dwa_control(x, config, goal, ob):\n    \"\"\"\n    Dynamic Window Approach control\n    \"\"\"\n    dw = calc_dynamic_window(x, config)\n    u, trajectory = calc_control_and_trajectory(x, dw, config, goal, ob)\n    return u, trajectory\nclass RobotType(Enum):\n    circle = 0\n    rectangle = 1",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "motion",
        "kind": 2,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "def motion(x, u, dt):\n    \"\"\"\n    motion model\n    \"\"\"\n    x[2] += u[1] * dt\n    x[0] += u[0] * math.cos(x[2]) * dt\n    x[1] += u[0] * math.sin(x[2]) * dt\n    x[3] = u[0]\n    x[4] = u[1]\n    return x",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "calc_dynamic_window",
        "kind": 2,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "def calc_dynamic_window(x, config):\n    \"\"\"\n    calculation dynamic window based on current state x\n    \"\"\"\n    # Dynamic window from robot specification\n    Vs = [config.min_speed, config.max_speed,\n          -config.max_yaw_rate, config.max_yaw_rate]\n    # Dynamic window from motion model\n    Vd = [x[3] - config.max_accel * config.dt,\n          x[3] + config.max_accel * config.dt,",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "predict_trajectory",
        "kind": 2,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "def predict_trajectory(x_init, v, y, config):\n    \"\"\"\n    predict trajectory with an input\n    \"\"\"\n    x = np.array(x_init)\n    trajectory = np.array(x)\n    time = 0\n    while time <= config.predict_time:\n        x = motion(x, [v, y], config.dt)\n        trajectory = np.vstack((trajectory, x))",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "calc_control_and_trajectory",
        "kind": 2,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "def calc_control_and_trajectory(x, dw, config, goal, ob):\n    \"\"\"\n    calculation final input with dynamic window\n    \"\"\"\n    x_init = x[:]\n    min_cost = float(\"inf\")\n    best_u = [0.0, 0.0]\n    best_trajectory = np.array([x])\n    # evaluate all trajectory with sampled input in dynamic window\n    for v in np.arange(dw[0], dw[1], config.v_resolution):",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "calc_obstacle_cost",
        "kind": 2,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "def calc_obstacle_cost(trajectory, ob, config):\n    \"\"\"\n    calc obstacle cost inf: collision\n    \"\"\"\n    ox = ob[:, 0]\n    oy = ob[:, 1]\n    dx = trajectory[:, 0] - ox[:, None]\n    dy = trajectory[:, 1] - oy[:, None]\n    r = np.hypot(dx, dy)\n    if config.robot_type == RobotType.rectangle:",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "calc_to_goal_cost",
        "kind": 2,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "def calc_to_goal_cost(trajectory, goal):\n    \"\"\"\n        calc to goal cost with angle difference\n    \"\"\"\n    dx = goal[0] - trajectory[-1, 0]\n    dy = goal[1] - trajectory[-1, 1]\n    error_angle = math.atan2(dy, dx)\n    cost_angle = error_angle - trajectory[-1, 2]\n    cost = abs(math.atan2(math.sin(cost_angle), math.cos(cost_angle)))\n    return cost",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "plot_arrow",
        "kind": 2,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "def plot_arrow(x, y, yaw, length=0.5, width=0.1):  # pragma: no cover\n    plt.arrow(x, y, length * math.cos(yaw), length * math.sin(yaw),\n              head_length=width, head_width=width)\n    plt.plot(x, y)\ndef plot_robot(x, y, yaw, config):  # pragma: no cover\n    if config.robot_type == RobotType.rectangle:\n        outline = np.array([[-config.robot_length / 2, config.robot_length / 2,\n                             (config.robot_length / 2), -config.robot_length / 2,\n                             -config.robot_length / 2],\n                            [config.robot_width / 2, config.robot_width / 2,",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "plot_robot",
        "kind": 2,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "def plot_robot(x, y, yaw, config):  # pragma: no cover\n    if config.robot_type == RobotType.rectangle:\n        outline = np.array([[-config.robot_length / 2, config.robot_length / 2,\n                             (config.robot_length / 2), -config.robot_length / 2,\n                             -config.robot_length / 2],\n                            [config.robot_width / 2, config.robot_width / 2,\n                             - config.robot_width / 2, -config.robot_width / 2,\n                             config.robot_width / 2]])\n        Rot1 = np.array([[math.cos(yaw), math.sin(yaw)],\n                         [-math.sin(yaw), math.cos(yaw)]])",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "def main(gx=10.0, gy=10.0, robot_type=RobotType.circle):\n    print(__file__ + \" start!!\")\n    # initial state [x(m), y(m), yaw(rad), v(m/s), omega(rad/s)]\n    x = np.array([0.0, 0.0, math.pi / 8.0, 0.0, 0.0])\n    # goal position [x(m), y(m)]\n    goal = np.array([gx, gy])\n    # input [forward speed, yaw_rate]\n    config.robot_type = robot_type\n    trajectory = np.array(x)\n    ob = config.ob",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "show_animation = True\ndef dwa_control(x, config, goal, ob):\n    \"\"\"\n    Dynamic Window Approach control\n    \"\"\"\n    dw = calc_dynamic_window(x, config)\n    u, trajectory = calc_control_and_trajectory(x, dw, config, goal, ob)\n    return u, trajectory\nclass RobotType(Enum):\n    circle = 0",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "description": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "peekOfCode": "config = Config()\ndef motion(x, u, dt):\n    \"\"\"\n    motion model\n    \"\"\"\n    x[2] += u[1] * dt\n    x[0] += u[0] * math.cos(x[2]) * dt\n    x[1] += u[0] * math.sin(x[2]) * dt\n    x[3] = u[0]\n    x[4] = u[1]",
        "detail": "PathPlanning.DynamicWindowApproach.dynamic_window_approach",
        "documentation": {}
    },
    {
        "label": "FlowField",
        "kind": 6,
        "importPath": "PathPlanning.FlowField.flowfield",
        "description": "PathPlanning.FlowField.flowfield",
        "peekOfCode": "class FlowField:\n    def __init__(self, obs_grid, goal_x, goal_y, start_x, start_y,\n                 limit_x, limit_y):\n        self.start_pt = [start_x, start_y]\n        self.goal_pt = [goal_x, goal_y]\n        self.obs_grid = obs_grid\n        self.limit_x, self.limit_y = limit_x, limit_y\n        self.cost_field = {}\n        self.integration_field = {}\n        self.vector_field = {}",
        "detail": "PathPlanning.FlowField.flowfield",
        "documentation": {}
    },
    {
        "label": "draw_horizontal_line",
        "kind": 2,
        "importPath": "PathPlanning.FlowField.flowfield",
        "description": "PathPlanning.FlowField.flowfield",
        "peekOfCode": "def draw_horizontal_line(start_x, start_y, length, o_x, o_y, o_dict, path):\n    for i in range(start_x, start_x + length):\n        for j in range(start_y, start_y + 2):\n            o_x.append(i)\n            o_y.append(j)\n            o_dict[(i, j)] = path\ndef draw_vertical_line(start_x, start_y, length, o_x, o_y, o_dict, path):\n    for i in range(start_x, start_x + 2):\n        for j in range(start_y, start_y + length):\n            o_x.append(i)",
        "detail": "PathPlanning.FlowField.flowfield",
        "documentation": {}
    },
    {
        "label": "draw_vertical_line",
        "kind": 2,
        "importPath": "PathPlanning.FlowField.flowfield",
        "description": "PathPlanning.FlowField.flowfield",
        "peekOfCode": "def draw_vertical_line(start_x, start_y, length, o_x, o_y, o_dict, path):\n    for i in range(start_x, start_x + 2):\n        for j in range(start_y, start_y + length):\n            o_x.append(i)\n            o_y.append(j)\n            o_dict[(i, j)] = path\nclass FlowField:\n    def __init__(self, obs_grid, goal_x, goal_y, start_x, start_y,\n                 limit_x, limit_y):\n        self.start_pt = [start_x, start_y]",
        "detail": "PathPlanning.FlowField.flowfield",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "PathPlanning.FlowField.flowfield",
        "description": "PathPlanning.FlowField.flowfield",
        "peekOfCode": "def main():\n    # set obstacle positions\n    obs_dict = {}\n    for i in range(51):\n        for j in range(51):\n            obs_dict[(i, j)] = 'free'\n    o_x, o_y, m_x, m_y, h_x, h_y = [], [], [], [], [], []\n    s_x = 5.0\n    s_y = 5.0\n    g_x = 35.0",
        "detail": "PathPlanning.FlowField.flowfield",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "PathPlanning.FlowField.flowfield",
        "description": "PathPlanning.FlowField.flowfield",
        "peekOfCode": "show_animation = True\ndef draw_horizontal_line(start_x, start_y, length, o_x, o_y, o_dict, path):\n    for i in range(start_x, start_x + length):\n        for j in range(start_y, start_y + 2):\n            o_x.append(i)\n            o_y.append(j)\n            o_dict[(i, j)] = path\ndef draw_vertical_line(start_x, start_y, length, o_x, o_y, o_dict, path):\n    for i in range(start_x, start_x + 2):\n        for j in range(start_y, start_y + length):",
        "detail": "PathPlanning.FlowField.flowfield",
        "documentation": {}
    },
    {
        "label": "SweepSearcher",
        "kind": 6,
        "importPath": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "description": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "peekOfCode": "class SweepSearcher:\n    class SweepDirection(IntEnum):\n        UP = 1\n        DOWN = -1\n    class MovingDirection(IntEnum):\n        RIGHT = 1\n        LEFT = -1\n    def __init__(self,\n                 moving_direction, sweep_direction, x_inds_goal_y, goal_y):\n        self.moving_direction = moving_direction",
        "detail": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "documentation": {}
    },
    {
        "label": "find_sweep_direction_and_start_position",
        "kind": 2,
        "importPath": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "description": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "peekOfCode": "def find_sweep_direction_and_start_position(ox, oy):\n    # find sweep_direction\n    max_dist = 0.0\n    vec = [0.0, 0.0]\n    sweep_start_pos = [0.0, 0.0]\n    for i in range(len(ox) - 1):\n        dx = ox[i + 1] - ox[i]\n        dy = oy[i + 1] - oy[i]\n        d = np.hypot(dx, dy)\n        if d > max_dist:",
        "detail": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "documentation": {}
    },
    {
        "label": "convert_grid_coordinate",
        "kind": 2,
        "importPath": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "description": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "peekOfCode": "def convert_grid_coordinate(ox, oy, sweep_vec, sweep_start_position):\n    tx = [ix - sweep_start_position[0] for ix in ox]\n    ty = [iy - sweep_start_position[1] for iy in oy]\n    th = math.atan2(sweep_vec[1], sweep_vec[0])\n    converted_xy = np.stack([tx, ty]).T @ rot_mat_2d(th)\n    return converted_xy[:, 0], converted_xy[:, 1]\ndef convert_global_coordinate(x, y, sweep_vec, sweep_start_position):\n    th = math.atan2(sweep_vec[1], sweep_vec[0])\n    converted_xy = np.stack([x, y]).T @ rot_mat_2d(-th)\n    rx = [ix + sweep_start_position[0] for ix in converted_xy[:, 0]]",
        "detail": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "documentation": {}
    },
    {
        "label": "convert_global_coordinate",
        "kind": 2,
        "importPath": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "description": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "peekOfCode": "def convert_global_coordinate(x, y, sweep_vec, sweep_start_position):\n    th = math.atan2(sweep_vec[1], sweep_vec[0])\n    converted_xy = np.stack([x, y]).T @ rot_mat_2d(-th)\n    rx = [ix + sweep_start_position[0] for ix in converted_xy[:, 0]]\n    ry = [iy + sweep_start_position[1] for iy in converted_xy[:, 1]]\n    return rx, ry\ndef search_free_grid_index_at_edge_y(grid_map, from_upper=False):\n    y_index = None\n    x_indexes = []\n    if from_upper:",
        "detail": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "documentation": {}
    },
    {
        "label": "search_free_grid_index_at_edge_y",
        "kind": 2,
        "importPath": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "description": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "peekOfCode": "def search_free_grid_index_at_edge_y(grid_map, from_upper=False):\n    y_index = None\n    x_indexes = []\n    if from_upper:\n        x_range = range(grid_map.height)[::-1]\n        y_range = range(grid_map.width)[::-1]\n    else:\n        x_range = range(grid_map.height)\n        y_range = range(grid_map.width)\n    for iy in x_range:",
        "detail": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "documentation": {}
    },
    {
        "label": "setup_grid_map",
        "kind": 2,
        "importPath": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "description": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "peekOfCode": "def setup_grid_map(ox, oy, resolution, sweep_direction, offset_grid=10):\n    width = math.ceil((max(ox) - min(ox)) / resolution) + offset_grid\n    height = math.ceil((max(oy) - min(oy)) / resolution) + offset_grid\n    center_x = (np.max(ox) + np.min(ox)) / 2.0\n    center_y = (np.max(oy) + np.min(oy)) / 2.0\n    grid_map = GridMap(width, height, resolution, center_x, center_y)\n    grid_map.print_grid_map_info()\n    grid_map.set_value_from_polygon(ox, oy, FloatGrid(1.0), inside=False)\n    grid_map.expand_grid()\n    x_inds_goal_y = []",
        "detail": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "documentation": {}
    },
    {
        "label": "sweep_path_search",
        "kind": 2,
        "importPath": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "description": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "peekOfCode": "def sweep_path_search(sweep_searcher, grid_map, grid_search_animation=False):\n    # search start grid\n    c_x_index, c_y_index = sweep_searcher.search_start_grid(grid_map)\n    if not grid_map.set_value_from_xy_index(c_x_index, c_y_index, FloatGrid(0.5)):\n        print(\"Cannot find start grid\")\n        return [], []\n    x, y = grid_map.calc_grid_central_xy_position_from_xy_index(c_x_index,\n                                                                c_y_index)\n    px, py = [x], [y]\n    fig, ax = None, None",
        "detail": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "documentation": {}
    },
    {
        "label": "planning",
        "kind": 2,
        "importPath": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "description": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "peekOfCode": "def planning(ox, oy, resolution,\n             moving_direction=SweepSearcher.MovingDirection.RIGHT,\n             sweeping_direction=SweepSearcher.SweepDirection.UP,\n             ):\n    sweep_vec, sweep_start_position = find_sweep_direction_and_start_position(\n        ox, oy)\n    rox, roy = convert_grid_coordinate(ox, oy, sweep_vec,\n                                       sweep_start_position)\n    grid_map, x_inds_goal_y, goal_y = setup_grid_map(rox, roy, resolution,\n                                                     sweeping_direction)",
        "detail": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "documentation": {}
    },
    {
        "label": "planning_animation",
        "kind": 2,
        "importPath": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "description": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "peekOfCode": "def planning_animation(ox, oy, resolution):  # pragma: no cover\n    px, py = planning(ox, oy, resolution)\n    # animation\n    if do_animation:\n        for ipx, ipy in zip(px, py):\n            plt.cla()\n            # for stopping simulation with the esc key.\n            plt.gcf().canvas.mpl_connect(\n                'key_release_event',\n                lambda event: [exit(0) if event.key == 'escape' else None])",
        "detail": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "description": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "peekOfCode": "def main():  # pragma: no cover\n    print(\"start!!\")\n    ox = [0.0, 20.0, 50.0, 100.0, 130.0, 40.0, 0.0]\n    oy = [0.0, -20.0, 0.0, 30.0, 60.0, 80.0, 0.0]\n    resolution = 5.0\n    planning_animation(ox, oy, resolution)\n    ox = [0.0, 50.0, 50.0, 0.0, 0.0]\n    oy = [0.0, 0.0, 30.0, 30.0, 0.0]\n    resolution = 1.3\n    planning_animation(ox, oy, resolution)",
        "detail": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "documentation": {}
    },
    {
        "label": "do_animation",
        "kind": 5,
        "importPath": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "description": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "peekOfCode": "do_animation = True\nclass SweepSearcher:\n    class SweepDirection(IntEnum):\n        UP = 1\n        DOWN = -1\n    class MovingDirection(IntEnum):\n        RIGHT = 1\n        LEFT = -1\n    def __init__(self,\n                 moving_direction, sweep_direction, x_inds_goal_y, goal_y):",
        "detail": "PathPlanning.GridBasedSweepCPP.grid_based_sweep_coverage_path_planner",
        "documentation": {}
    },
    {
        "label": "calc_potential_field",
        "kind": 2,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "def calc_potential_field(gx, gy, ox, oy, reso, rr, sx, sy):\n    minx = min(min(ox), sx, gx) - AREA_WIDTH / 2.0\n    miny = min(min(oy), sy, gy) - AREA_WIDTH / 2.0\n    maxx = max(max(ox), sx, gx) + AREA_WIDTH / 2.0\n    maxy = max(max(oy), sy, gy) + AREA_WIDTH / 2.0\n    xw = int(round((maxx - minx) / reso))\n    yw = int(round((maxy - miny) / reso))\n    # calc each potential\n    pmap = [[0.0 for i in range(yw)] for i in range(xw)]\n    for ix in range(xw):",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "calc_attractive_potential",
        "kind": 2,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "def calc_attractive_potential(x, y, gx, gy):\n    return 0.5 * KP * np.hypot(x - gx, y - gy)\ndef calc_repulsive_potential(x, y, ox, oy, rr):\n    # search nearest obstacle\n    minid = -1\n    dmin = float(\"inf\")\n    for i, _ in enumerate(ox):\n        d = np.hypot(x - ox[i], y - oy[i])\n        if dmin >= d:\n            dmin = d",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "calc_repulsive_potential",
        "kind": 2,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "def calc_repulsive_potential(x, y, ox, oy, rr):\n    # search nearest obstacle\n    minid = -1\n    dmin = float(\"inf\")\n    for i, _ in enumerate(ox):\n        d = np.hypot(x - ox[i], y - oy[i])\n        if dmin >= d:\n            dmin = d\n            minid = i\n    # calc repulsive potential",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "get_motion_model",
        "kind": 2,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "def get_motion_model():\n    # dx, dy\n    motion = [[1, 0],\n              [0, 1],\n              [-1, 0],\n              [0, -1],\n              [-1, -1],\n              [-1, 1],\n              [1, -1],\n              [1, 1]]",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "oscillations_detection",
        "kind": 2,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "def oscillations_detection(previous_ids, ix, iy):\n    previous_ids.append((ix, iy))\n    if (len(previous_ids) > OSCILLATIONS_DETECTION_LENGTH):\n        previous_ids.popleft()\n    # check if contains any duplicates by copying into a set\n    previous_ids_set = set()\n    for index in previous_ids:\n        if index in previous_ids_set:\n            return True\n        else:",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "potential_field_planning",
        "kind": 2,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "def potential_field_planning(sx, sy, gx, gy, ox, oy, reso, rr):\n    # calc potential field\n    pmap, minx, miny = calc_potential_field(gx, gy, ox, oy, reso, rr, sx, sy)\n    # search path\n    d = np.hypot(sx - gx, sy - gy)\n    ix = round((sx - minx) / reso)\n    iy = round((sy - miny) / reso)\n    gix = round((gx - minx) / reso)\n    giy = round((gy - miny) / reso)\n    if show_animation:",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "draw_heatmap",
        "kind": 2,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "def draw_heatmap(data):\n    data = np.array(data).T\n    plt.pcolor(data, vmax=100.0, cmap=plt.cm.Blues)\ndef main():\n    print(\"potential_field_planning start\")\n    sx = 0.0  # start x position [m]\n    sy = 10.0  # start y positon [m]\n    gx = 30.0  # goal x position [m]\n    gy = 30.0  # goal y position [m]\n    grid_size = 0.5  # potential grid size [m]",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "def main():\n    print(\"potential_field_planning start\")\n    sx = 0.0  # start x position [m]\n    sy = 10.0  # start y positon [m]\n    gx = 30.0  # goal x position [m]\n    gy = 30.0  # goal y position [m]\n    grid_size = 0.5  # potential grid size [m]\n    robot_radius = 5.0  # robot radius [m]\n    ox = [15.0, 5.0, 20.0, 25.0]  # obstacle x position list [m]\n    oy = [25.0, 15.0, 26.0, 25.0]  # obstacle y position list [m]",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "KP",
        "kind": 5,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "KP = 5.0  # attractive potential gain\nETA = 100.0  # repulsive potential gain\nAREA_WIDTH = 30.0  # potential area width [m]\n# the number of previous positions used to check oscillations\nOSCILLATIONS_DETECTION_LENGTH = 3\nshow_animation = True\ndef calc_potential_field(gx, gy, ox, oy, reso, rr, sx, sy):\n    minx = min(min(ox), sx, gx) - AREA_WIDTH / 2.0\n    miny = min(min(oy), sy, gy) - AREA_WIDTH / 2.0\n    maxx = max(max(ox), sx, gx) + AREA_WIDTH / 2.0",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "ETA",
        "kind": 5,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "ETA = 100.0  # repulsive potential gain\nAREA_WIDTH = 30.0  # potential area width [m]\n# the number of previous positions used to check oscillations\nOSCILLATIONS_DETECTION_LENGTH = 3\nshow_animation = True\ndef calc_potential_field(gx, gy, ox, oy, reso, rr, sx, sy):\n    minx = min(min(ox), sx, gx) - AREA_WIDTH / 2.0\n    miny = min(min(oy), sy, gy) - AREA_WIDTH / 2.0\n    maxx = max(max(ox), sx, gx) + AREA_WIDTH / 2.0\n    maxy = max(max(oy), sy, gy) + AREA_WIDTH / 2.0",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "AREA_WIDTH",
        "kind": 5,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "AREA_WIDTH = 30.0  # potential area width [m]\n# the number of previous positions used to check oscillations\nOSCILLATIONS_DETECTION_LENGTH = 3\nshow_animation = True\ndef calc_potential_field(gx, gy, ox, oy, reso, rr, sx, sy):\n    minx = min(min(ox), sx, gx) - AREA_WIDTH / 2.0\n    miny = min(min(oy), sy, gy) - AREA_WIDTH / 2.0\n    maxx = max(max(ox), sx, gx) + AREA_WIDTH / 2.0\n    maxy = max(max(oy), sy, gy) + AREA_WIDTH / 2.0\n    xw = int(round((maxx - minx) / reso))",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "OSCILLATIONS_DETECTION_LENGTH",
        "kind": 5,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "OSCILLATIONS_DETECTION_LENGTH = 3\nshow_animation = True\ndef calc_potential_field(gx, gy, ox, oy, reso, rr, sx, sy):\n    minx = min(min(ox), sx, gx) - AREA_WIDTH / 2.0\n    miny = min(min(oy), sy, gy) - AREA_WIDTH / 2.0\n    maxx = max(max(ox), sx, gx) + AREA_WIDTH / 2.0\n    maxy = max(max(oy), sy, gy) + AREA_WIDTH / 2.0\n    xw = int(round((maxx - minx) / reso))\n    yw = int(round((maxy - miny) / reso))\n    # calc each potential",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "description": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "peekOfCode": "show_animation = True\ndef calc_potential_field(gx, gy, ox, oy, reso, rr, sx, sy):\n    minx = min(min(ox), sx, gx) - AREA_WIDTH / 2.0\n    miny = min(min(oy), sy, gy) - AREA_WIDTH / 2.0\n    maxx = max(max(ox), sx, gx) + AREA_WIDTH / 2.0\n    maxy = max(max(oy), sy, gy) + AREA_WIDTH / 2.0\n    xw = int(round((maxx - minx) / reso))\n    yw = int(round((maxy - miny) / reso))\n    # calc each potential\n    pmap = [[0.0 for i in range(yw)] for i in range(xw)]",
        "detail": "PathPlanning.PotentialFieldPlanning.potential_field_planning",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "class State:\n    \"\"\"\n    vehicle state class\n    \"\"\"\n    def __init__(self, x=0.0, y=0.0, yaw=0.0, v=0.0):\n        self.x = x\n        self.y = y\n        self.yaw = yaw\n        self.v = v\n        self.predelta = None",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "pi_2_pi",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def pi_2_pi(angle):\n    return angle_mod(angle)\ndef get_linear_model_matrix(v, phi, delta):\n    A = np.zeros((NX, NX))\n    A[0, 0] = 1.0\n    A[1, 1] = 1.0\n    A[2, 2] = 1.0\n    A[3, 3] = 1.0\n    A[0, 2] = DT * math.cos(phi)\n    A[0, 3] = - DT * v * math.sin(phi)",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "get_linear_model_matrix",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def get_linear_model_matrix(v, phi, delta):\n    A = np.zeros((NX, NX))\n    A[0, 0] = 1.0\n    A[1, 1] = 1.0\n    A[2, 2] = 1.0\n    A[3, 3] = 1.0\n    A[0, 2] = DT * math.cos(phi)\n    A[0, 3] = - DT * v * math.sin(phi)\n    A[1, 2] = DT * math.sin(phi)\n    A[1, 3] = DT * v * math.cos(phi)",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "plot_car",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def plot_car(x, y, yaw, steer=0.0, cabcolor=\"-r\", truckcolor=\"-k\"):  # pragma: no cover\n    outline = np.array([[-BACKTOWHEEL, (LENGTH - BACKTOWHEEL), (LENGTH - BACKTOWHEEL), -BACKTOWHEEL, -BACKTOWHEEL],\n                        [WIDTH / 2, WIDTH / 2, - WIDTH / 2, -WIDTH / 2, WIDTH / 2]])\n    fr_wheel = np.array([[WHEEL_LEN, -WHEEL_LEN, -WHEEL_LEN, WHEEL_LEN, WHEEL_LEN],\n                         [-WHEEL_WIDTH - TREAD, -WHEEL_WIDTH - TREAD, WHEEL_WIDTH - TREAD, WHEEL_WIDTH - TREAD, -WHEEL_WIDTH - TREAD]])\n    rr_wheel = np.copy(fr_wheel)\n    fl_wheel = np.copy(fr_wheel)\n    fl_wheel[1, :] *= -1\n    rl_wheel = np.copy(rr_wheel)\n    rl_wheel[1, :] *= -1",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "update_state",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def update_state(state, a, delta):\n    # input check\n    if delta >= MAX_STEER:\n        delta = MAX_STEER\n    elif delta <= -MAX_STEER:\n        delta = -MAX_STEER\n    state.x = state.x + state.v * math.cos(state.yaw) * DT\n    state.y = state.y + state.v * math.sin(state.yaw) * DT\n    state.yaw = state.yaw + state.v / WB * math.tan(delta) * DT\n    state.v = state.v + a * DT",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "get_nparray_from_matrix",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def get_nparray_from_matrix(x):\n    return np.array(x).flatten()\ndef calc_nearest_index(state, cx, cy, cyaw, pind):\n    dx = [state.x - icx for icx in cx[pind:(pind + N_IND_SEARCH)]]\n    dy = [state.y - icy for icy in cy[pind:(pind + N_IND_SEARCH)]]\n    d = [idx ** 2 + idy ** 2 for (idx, idy) in zip(dx, dy)]\n    mind = min(d)\n    ind = d.index(mind) + pind\n    mind = math.sqrt(mind)\n    dxl = cx[ind] - state.x",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "calc_nearest_index",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def calc_nearest_index(state, cx, cy, cyaw, pind):\n    dx = [state.x - icx for icx in cx[pind:(pind + N_IND_SEARCH)]]\n    dy = [state.y - icy for icy in cy[pind:(pind + N_IND_SEARCH)]]\n    d = [idx ** 2 + idy ** 2 for (idx, idy) in zip(dx, dy)]\n    mind = min(d)\n    ind = d.index(mind) + pind\n    mind = math.sqrt(mind)\n    dxl = cx[ind] - state.x\n    dyl = cy[ind] - state.y\n    angle = pi_2_pi(cyaw[ind] - math.atan2(dyl, dxl))",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "predict_motion",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def predict_motion(x0, oa, od, xref):\n    xbar = xref * 0.0\n    for i, _ in enumerate(x0):\n        xbar[i, 0] = x0[i]\n    state = State(x=x0[0], y=x0[1], yaw=x0[3], v=x0[2])\n    for (ai, di, i) in zip(oa, od, range(1, T + 1)):\n        state = update_state(state, ai, di)\n        xbar[0, i] = state.x\n        xbar[1, i] = state.y\n        xbar[2, i] = state.v",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "iterative_linear_mpc_control",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def iterative_linear_mpc_control(xref, x0, dref, oa, od):\n    \"\"\"\n    MPC control with updating operational point iteratively\n    \"\"\"\n    ox, oy, oyaw, ov = None, None, None, None\n    if oa is None or od is None:\n        oa = [0.0] * T\n        od = [0.0] * T\n    for i in range(MAX_ITER):\n        xbar = predict_motion(x0, oa, od, xref)",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "linear_mpc_control",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def linear_mpc_control(xref, xbar, x0, dref):\n    \"\"\"\n    linear mpc control\n    xref: reference point\n    xbar: operational point\n    x0: initial state\n    dref: reference steer angle\n    \"\"\"\n    x = cvxpy.Variable((NX, T + 1))\n    u = cvxpy.Variable((NU, T))",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "calc_ref_trajectory",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def calc_ref_trajectory(state, cx, cy, cyaw, ck, sp, dl, pind):\n    xref = np.zeros((NX, T + 1))\n    dref = np.zeros((1, T + 1))\n    ncourse = len(cx)\n    ind, _ = calc_nearest_index(state, cx, cy, cyaw, pind)\n    if pind >= ind:\n        ind = pind\n    xref[0, 0] = cx[ind]\n    xref[1, 0] = cy[ind]\n    xref[2, 0] = sp[ind]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "check_goal",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def check_goal(state, goal, tind, nind):\n    # check goal\n    dx = state.x - goal[0]\n    dy = state.y - goal[1]\n    d = math.hypot(dx, dy)\n    isgoal = (d <= GOAL_DIS)\n    if abs(tind - nind) >= 5:\n        isgoal = False\n    isstop = (abs(state.v) <= STOP_SPEED)\n    if isgoal and isstop:",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "do_simulation",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def do_simulation(cx, cy, cyaw, ck, sp, dl, initial_state):\n    \"\"\"\n    Simulation\n    cx: course x position list\n    cy: course y position list\n    cy: course yaw position list\n    ck: course curvature list\n    sp: speed profile\n    dl: course tick [m]\n    \"\"\"",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "calc_speed_profile",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def calc_speed_profile(cx, cy, cyaw, target_speed):\n    speed_profile = [target_speed] * len(cx)\n    direction = 1.0  # forward\n    # Set stop point\n    for i in range(len(cx) - 1):\n        dx = cx[i + 1] - cx[i]\n        dy = cy[i + 1] - cy[i]\n        move_direction = math.atan2(dy, dx)\n        if dx != 0.0 and dy != 0.0:\n            dangle = abs(pi_2_pi(move_direction - cyaw[i]))",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "smooth_yaw",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def smooth_yaw(yaw):\n    for i in range(len(yaw) - 1):\n        dyaw = yaw[i + 1] - yaw[i]\n        while dyaw >= math.pi / 2.0:\n            yaw[i + 1] -= math.pi * 2.0\n            dyaw = yaw[i + 1] - yaw[i]\n        while dyaw <= -math.pi / 2.0:\n            yaw[i + 1] += math.pi * 2.0\n            dyaw = yaw[i + 1] - yaw[i]\n    return yaw",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "get_straight_course",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def get_straight_course(dl):\n    ax = [0.0, 5.0, 10.0, 20.0, 30.0, 40.0, 50.0]\n    ay = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    cx, cy, cyaw, ck, s = cubic_spline_planner.calc_spline_course(\n        ax, ay, ds=dl)\n    return cx, cy, cyaw, ck\ndef get_straight_course2(dl):\n    ax = [0.0, -10.0, -20.0, -40.0, -50.0, -60.0, -70.0]\n    ay = [0.0, -1.0, 1.0, 0.0, -1.0, 1.0, 0.0]\n    cx, cy, cyaw, ck, s = cubic_spline_planner.calc_spline_course(",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "get_straight_course2",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def get_straight_course2(dl):\n    ax = [0.0, -10.0, -20.0, -40.0, -50.0, -60.0, -70.0]\n    ay = [0.0, -1.0, 1.0, 0.0, -1.0, 1.0, 0.0]\n    cx, cy, cyaw, ck, s = cubic_spline_planner.calc_spline_course(\n        ax, ay, ds=dl)\n    return cx, cy, cyaw, ck\ndef get_straight_course3(dl):\n    ax = [0.0, -10.0, -20.0, -40.0, -50.0, -60.0, -70.0]\n    ay = [0.0, -1.0, 1.0, 0.0, -1.0, 1.0, 0.0]\n    cx, cy, cyaw, ck, s = cubic_spline_planner.calc_spline_course(",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "get_straight_course3",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def get_straight_course3(dl):\n    ax = [0.0, -10.0, -20.0, -40.0, -50.0, -60.0, -70.0]\n    ay = [0.0, -1.0, 1.0, 0.0, -1.0, 1.0, 0.0]\n    cx, cy, cyaw, ck, s = cubic_spline_planner.calc_spline_course(\n        ax, ay, ds=dl)\n    cyaw = [i - math.pi for i in cyaw]\n    return cx, cy, cyaw, ck\ndef get_forward_course(dl):\n    ax = [0.0, 60.0, 125.0, 50.0, 75.0, 30.0, -10.0]\n    ay = [0.0, 0.0, 50.0, 65.0, 30.0, 50.0, -20.0]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "get_forward_course",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def get_forward_course(dl):\n    ax = [0.0, 60.0, 125.0, 50.0, 75.0, 30.0, -10.0]\n    ay = [0.0, 0.0, 50.0, 65.0, 30.0, 50.0, -20.0]\n    cx, cy, cyaw, ck, s = cubic_spline_planner.calc_spline_course(\n        ax, ay, ds=dl)\n    return cx, cy, cyaw, ck\ndef get_switch_back_course(dl):\n    ax = [0.0, 30.0, 6.0, 20.0, 35.0]\n    ay = [0.0, 0.0, 20.0, 35.0, 20.0]\n    cx, cy, cyaw, ck, s = cubic_spline_planner.calc_spline_course(",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "get_switch_back_course",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def get_switch_back_course(dl):\n    ax = [0.0, 30.0, 6.0, 20.0, 35.0]\n    ay = [0.0, 0.0, 20.0, 35.0, 20.0]\n    cx, cy, cyaw, ck, s = cubic_spline_planner.calc_spline_course(\n        ax, ay, ds=dl)\n    ax = [35.0, 10.0, 0.0, 0.0]\n    ay = [20.0, 30.0, 5.0, 0.0]\n    cx2, cy2, cyaw2, ck2, s2 = cubic_spline_planner.calc_spline_course(\n        ax, ay, ds=dl)\n    cyaw2 = [i - math.pi for i in cyaw2]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def main():\n    print(__file__ + \" start!!\")\n    dl = 1.0  # course tick\n    # cx, cy, cyaw, ck = get_straight_course(dl)\n    # cx, cy, cyaw, ck = get_straight_course2(dl)\n    # cx, cy, cyaw, ck = get_straight_course3(dl)\n    # cx, cy, cyaw, ck = get_forward_course(dl)\n    cx, cy, cyaw, ck = get_switch_back_course(dl)\n    sp = calc_speed_profile(cx, cy, cyaw, TARGET_SPEED)\n    initial_state = State(x=cx[0], y=cy[0], yaw=cyaw[0], v=0.0)",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "main2",
        "kind": 2,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "def main2():\n    print(__file__ + \" start!!\")\n    dl = 1.0  # course tick\n    cx, cy, cyaw, ck = get_straight_course3(dl)\n    sp = calc_speed_profile(cx, cy, cyaw, TARGET_SPEED)\n    initial_state = State(x=cx[0], y=cy[0], yaw=0.0, v=0.0)\n    t, x, y, yaw, v, d, a = do_simulation(\n        cx, cy, cyaw, ck, sp, dl, initial_state)\n    if show_animation:  # pragma: no cover\n        plt.close(\"all\")",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "NX",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "NX = 4  # x = x, y, v, yaw\nNU = 2  # a = [accel, steer]\nT = 5  # horizon length\n# mpc parameters\nR = np.diag([0.01, 0.01])  # input cost matrix\nRd = np.diag([0.01, 1.0])  # input difference cost matrix\nQ = np.diag([1.0, 1.0, 0.5, 0.5])  # state cost matrix\nQf = Q  # state final matrix\nGOAL_DIS = 1.5  # goal distance\nSTOP_SPEED = 0.5 / 3.6  # stop speed",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "NU",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "NU = 2  # a = [accel, steer]\nT = 5  # horizon length\n# mpc parameters\nR = np.diag([0.01, 0.01])  # input cost matrix\nRd = np.diag([0.01, 1.0])  # input difference cost matrix\nQ = np.diag([1.0, 1.0, 0.5, 0.5])  # state cost matrix\nQf = Q  # state final matrix\nGOAL_DIS = 1.5  # goal distance\nSTOP_SPEED = 0.5 / 3.6  # stop speed\nMAX_TIME = 500.0  # max simulation time",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "T = 5  # horizon length\n# mpc parameters\nR = np.diag([0.01, 0.01])  # input cost matrix\nRd = np.diag([0.01, 1.0])  # input difference cost matrix\nQ = np.diag([1.0, 1.0, 0.5, 0.5])  # state cost matrix\nQf = Q  # state final matrix\nGOAL_DIS = 1.5  # goal distance\nSTOP_SPEED = 0.5 / 3.6  # stop speed\nMAX_TIME = 500.0  # max simulation time\n# iterative paramter",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "R",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "R = np.diag([0.01, 0.01])  # input cost matrix\nRd = np.diag([0.01, 1.0])  # input difference cost matrix\nQ = np.diag([1.0, 1.0, 0.5, 0.5])  # state cost matrix\nQf = Q  # state final matrix\nGOAL_DIS = 1.5  # goal distance\nSTOP_SPEED = 0.5 / 3.6  # stop speed\nMAX_TIME = 500.0  # max simulation time\n# iterative paramter\nMAX_ITER = 3  # Max iteration\nDU_TH = 0.1  # iteration finish param",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "Rd",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "Rd = np.diag([0.01, 1.0])  # input difference cost matrix\nQ = np.diag([1.0, 1.0, 0.5, 0.5])  # state cost matrix\nQf = Q  # state final matrix\nGOAL_DIS = 1.5  # goal distance\nSTOP_SPEED = 0.5 / 3.6  # stop speed\nMAX_TIME = 500.0  # max simulation time\n# iterative paramter\nMAX_ITER = 3  # Max iteration\nDU_TH = 0.1  # iteration finish param\nTARGET_SPEED = 10.0 / 3.6  # [m/s] target speed",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "Q",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "Q = np.diag([1.0, 1.0, 0.5, 0.5])  # state cost matrix\nQf = Q  # state final matrix\nGOAL_DIS = 1.5  # goal distance\nSTOP_SPEED = 0.5 / 3.6  # stop speed\nMAX_TIME = 500.0  # max simulation time\n# iterative paramter\nMAX_ITER = 3  # Max iteration\nDU_TH = 0.1  # iteration finish param\nTARGET_SPEED = 10.0 / 3.6  # [m/s] target speed\nN_IND_SEARCH = 10  # Search index number",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "Qf",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "Qf = Q  # state final matrix\nGOAL_DIS = 1.5  # goal distance\nSTOP_SPEED = 0.5 / 3.6  # stop speed\nMAX_TIME = 500.0  # max simulation time\n# iterative paramter\nMAX_ITER = 3  # Max iteration\nDU_TH = 0.1  # iteration finish param\nTARGET_SPEED = 10.0 / 3.6  # [m/s] target speed\nN_IND_SEARCH = 10  # Search index number\nDT = 0.2  # [s] time tick",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "GOAL_DIS",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "GOAL_DIS = 1.5  # goal distance\nSTOP_SPEED = 0.5 / 3.6  # stop speed\nMAX_TIME = 500.0  # max simulation time\n# iterative paramter\nMAX_ITER = 3  # Max iteration\nDU_TH = 0.1  # iteration finish param\nTARGET_SPEED = 10.0 / 3.6  # [m/s] target speed\nN_IND_SEARCH = 10  # Search index number\nDT = 0.2  # [s] time tick\n# Vehicle parameters",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "STOP_SPEED",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "STOP_SPEED = 0.5 / 3.6  # stop speed\nMAX_TIME = 500.0  # max simulation time\n# iterative paramter\nMAX_ITER = 3  # Max iteration\nDU_TH = 0.1  # iteration finish param\nTARGET_SPEED = 10.0 / 3.6  # [m/s] target speed\nN_IND_SEARCH = 10  # Search index number\nDT = 0.2  # [s] time tick\n# Vehicle parameters\nLENGTH = 4.5  # [m]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "MAX_TIME",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "MAX_TIME = 500.0  # max simulation time\n# iterative paramter\nMAX_ITER = 3  # Max iteration\nDU_TH = 0.1  # iteration finish param\nTARGET_SPEED = 10.0 / 3.6  # [m/s] target speed\nN_IND_SEARCH = 10  # Search index number\nDT = 0.2  # [s] time tick\n# Vehicle parameters\nLENGTH = 4.5  # [m]\nWIDTH = 2.0  # [m]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "MAX_ITER",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "MAX_ITER = 3  # Max iteration\nDU_TH = 0.1  # iteration finish param\nTARGET_SPEED = 10.0 / 3.6  # [m/s] target speed\nN_IND_SEARCH = 10  # Search index number\nDT = 0.2  # [s] time tick\n# Vehicle parameters\nLENGTH = 4.5  # [m]\nWIDTH = 2.0  # [m]\nBACKTOWHEEL = 1.0  # [m]\nWHEEL_LEN = 0.3  # [m]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "DU_TH",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "DU_TH = 0.1  # iteration finish param\nTARGET_SPEED = 10.0 / 3.6  # [m/s] target speed\nN_IND_SEARCH = 10  # Search index number\nDT = 0.2  # [s] time tick\n# Vehicle parameters\nLENGTH = 4.5  # [m]\nWIDTH = 2.0  # [m]\nBACKTOWHEEL = 1.0  # [m]\nWHEEL_LEN = 0.3  # [m]\nWHEEL_WIDTH = 0.2  # [m]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "TARGET_SPEED",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "TARGET_SPEED = 10.0 / 3.6  # [m/s] target speed\nN_IND_SEARCH = 10  # Search index number\nDT = 0.2  # [s] time tick\n# Vehicle parameters\nLENGTH = 4.5  # [m]\nWIDTH = 2.0  # [m]\nBACKTOWHEEL = 1.0  # [m]\nWHEEL_LEN = 0.3  # [m]\nWHEEL_WIDTH = 0.2  # [m]\nTREAD = 0.7  # [m]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "N_IND_SEARCH",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "N_IND_SEARCH = 10  # Search index number\nDT = 0.2  # [s] time tick\n# Vehicle parameters\nLENGTH = 4.5  # [m]\nWIDTH = 2.0  # [m]\nBACKTOWHEEL = 1.0  # [m]\nWHEEL_LEN = 0.3  # [m]\nWHEEL_WIDTH = 0.2  # [m]\nTREAD = 0.7  # [m]\nWB = 2.5  # [m]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "DT",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "DT = 0.2  # [s] time tick\n# Vehicle parameters\nLENGTH = 4.5  # [m]\nWIDTH = 2.0  # [m]\nBACKTOWHEEL = 1.0  # [m]\nWHEEL_LEN = 0.3  # [m]\nWHEEL_WIDTH = 0.2  # [m]\nTREAD = 0.7  # [m]\nWB = 2.5  # [m]\nMAX_STEER = np.deg2rad(45.0)  # maximum steering angle [rad]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "LENGTH",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "LENGTH = 4.5  # [m]\nWIDTH = 2.0  # [m]\nBACKTOWHEEL = 1.0  # [m]\nWHEEL_LEN = 0.3  # [m]\nWHEEL_WIDTH = 0.2  # [m]\nTREAD = 0.7  # [m]\nWB = 2.5  # [m]\nMAX_STEER = np.deg2rad(45.0)  # maximum steering angle [rad]\nMAX_DSTEER = np.deg2rad(30.0)  # maximum steering speed [rad/s]\nMAX_SPEED = 55.0 / 3.6  # maximum speed [m/s]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "WIDTH",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "WIDTH = 2.0  # [m]\nBACKTOWHEEL = 1.0  # [m]\nWHEEL_LEN = 0.3  # [m]\nWHEEL_WIDTH = 0.2  # [m]\nTREAD = 0.7  # [m]\nWB = 2.5  # [m]\nMAX_STEER = np.deg2rad(45.0)  # maximum steering angle [rad]\nMAX_DSTEER = np.deg2rad(30.0)  # maximum steering speed [rad/s]\nMAX_SPEED = 55.0 / 3.6  # maximum speed [m/s]\nMIN_SPEED = -20.0 / 3.6  # minimum speed [m/s]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "BACKTOWHEEL",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "BACKTOWHEEL = 1.0  # [m]\nWHEEL_LEN = 0.3  # [m]\nWHEEL_WIDTH = 0.2  # [m]\nTREAD = 0.7  # [m]\nWB = 2.5  # [m]\nMAX_STEER = np.deg2rad(45.0)  # maximum steering angle [rad]\nMAX_DSTEER = np.deg2rad(30.0)  # maximum steering speed [rad/s]\nMAX_SPEED = 55.0 / 3.6  # maximum speed [m/s]\nMIN_SPEED = -20.0 / 3.6  # minimum speed [m/s]\nMAX_ACCEL = 1.0  # maximum accel [m/ss]",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "WHEEL_LEN",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "WHEEL_LEN = 0.3  # [m]\nWHEEL_WIDTH = 0.2  # [m]\nTREAD = 0.7  # [m]\nWB = 2.5  # [m]\nMAX_STEER = np.deg2rad(45.0)  # maximum steering angle [rad]\nMAX_DSTEER = np.deg2rad(30.0)  # maximum steering speed [rad/s]\nMAX_SPEED = 55.0 / 3.6  # maximum speed [m/s]\nMIN_SPEED = -20.0 / 3.6  # minimum speed [m/s]\nMAX_ACCEL = 1.0  # maximum accel [m/ss]\nshow_animation = True",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "WHEEL_WIDTH",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "WHEEL_WIDTH = 0.2  # [m]\nTREAD = 0.7  # [m]\nWB = 2.5  # [m]\nMAX_STEER = np.deg2rad(45.0)  # maximum steering angle [rad]\nMAX_DSTEER = np.deg2rad(30.0)  # maximum steering speed [rad/s]\nMAX_SPEED = 55.0 / 3.6  # maximum speed [m/s]\nMIN_SPEED = -20.0 / 3.6  # minimum speed [m/s]\nMAX_ACCEL = 1.0  # maximum accel [m/ss]\nshow_animation = True\nclass State:",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "TREAD",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "TREAD = 0.7  # [m]\nWB = 2.5  # [m]\nMAX_STEER = np.deg2rad(45.0)  # maximum steering angle [rad]\nMAX_DSTEER = np.deg2rad(30.0)  # maximum steering speed [rad/s]\nMAX_SPEED = 55.0 / 3.6  # maximum speed [m/s]\nMIN_SPEED = -20.0 / 3.6  # minimum speed [m/s]\nMAX_ACCEL = 1.0  # maximum accel [m/ss]\nshow_animation = True\nclass State:\n    \"\"\"",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "WB",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "WB = 2.5  # [m]\nMAX_STEER = np.deg2rad(45.0)  # maximum steering angle [rad]\nMAX_DSTEER = np.deg2rad(30.0)  # maximum steering speed [rad/s]\nMAX_SPEED = 55.0 / 3.6  # maximum speed [m/s]\nMIN_SPEED = -20.0 / 3.6  # minimum speed [m/s]\nMAX_ACCEL = 1.0  # maximum accel [m/ss]\nshow_animation = True\nclass State:\n    \"\"\"\n    vehicle state class",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "MAX_STEER",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "MAX_STEER = np.deg2rad(45.0)  # maximum steering angle [rad]\nMAX_DSTEER = np.deg2rad(30.0)  # maximum steering speed [rad/s]\nMAX_SPEED = 55.0 / 3.6  # maximum speed [m/s]\nMIN_SPEED = -20.0 / 3.6  # minimum speed [m/s]\nMAX_ACCEL = 1.0  # maximum accel [m/ss]\nshow_animation = True\nclass State:\n    \"\"\"\n    vehicle state class\n    \"\"\"",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "MAX_DSTEER",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "MAX_DSTEER = np.deg2rad(30.0)  # maximum steering speed [rad/s]\nMAX_SPEED = 55.0 / 3.6  # maximum speed [m/s]\nMIN_SPEED = -20.0 / 3.6  # minimum speed [m/s]\nMAX_ACCEL = 1.0  # maximum accel [m/ss]\nshow_animation = True\nclass State:\n    \"\"\"\n    vehicle state class\n    \"\"\"\n    def __init__(self, x=0.0, y=0.0, yaw=0.0, v=0.0):",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "MAX_SPEED",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "MAX_SPEED = 55.0 / 3.6  # maximum speed [m/s]\nMIN_SPEED = -20.0 / 3.6  # minimum speed [m/s]\nMAX_ACCEL = 1.0  # maximum accel [m/ss]\nshow_animation = True\nclass State:\n    \"\"\"\n    vehicle state class\n    \"\"\"\n    def __init__(self, x=0.0, y=0.0, yaw=0.0, v=0.0):\n        self.x = x",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "MIN_SPEED",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "MIN_SPEED = -20.0 / 3.6  # minimum speed [m/s]\nMAX_ACCEL = 1.0  # maximum accel [m/ss]\nshow_animation = True\nclass State:\n    \"\"\"\n    vehicle state class\n    \"\"\"\n    def __init__(self, x=0.0, y=0.0, yaw=0.0, v=0.0):\n        self.x = x\n        self.y = y",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "MAX_ACCEL",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "MAX_ACCEL = 1.0  # maximum accel [m/ss]\nshow_animation = True\nclass State:\n    \"\"\"\n    vehicle state class\n    \"\"\"\n    def __init__(self, x=0.0, y=0.0, yaw=0.0, v=0.0):\n        self.x = x\n        self.y = y\n        self.yaw = yaw",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "description": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "peekOfCode": "show_animation = True\nclass State:\n    \"\"\"\n    vehicle state class\n    \"\"\"\n    def __init__(self, x=0.0, y=0.0, yaw=0.0, v=0.0):\n        self.x = x\n        self.y = y\n        self.yaw = yaw\n        self.v = v",
        "detail": "PathTracking.model_predictive_speed_and_steer_control.model_predictive_speed_and_steer_control",
        "documentation": {}
    },
    {
        "label": "ekf_slam",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def ekf_slam(xEst, PEst, u, z):\n    # Predict\n    G, Fx = jacob_motion(xEst, u)\n    xEst[0:STATE_SIZE] = motion_model(xEst[0:STATE_SIZE], u)\n    PEst = G.T @ PEst @ G + Fx.T @ Cx @ Fx\n    initP = np.eye(2)\n    # Update\n    for iz in range(len(z[:, 0])):  # for each observation\n        min_id = search_correspond_landmark_id(xEst, PEst, z[iz, 0:2])\n        nLM = calc_n_lm(xEst)",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "calc_input",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def calc_input():\n    v = 1.0  # [m/s]\n    yaw_rate = 0.1  # [rad/s]\n    u = np.array([[v, yaw_rate]]).T\n    return u\ndef observation(xTrue, xd, u, RFID):\n    xTrue = motion_model(xTrue, u)\n    # add noise to gps x-y\n    z = np.zeros((0, 3))\n    for i in range(len(RFID[:, 0])):",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "observation",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def observation(xTrue, xd, u, RFID):\n    xTrue = motion_model(xTrue, u)\n    # add noise to gps x-y\n    z = np.zeros((0, 3))\n    for i in range(len(RFID[:, 0])):\n        dx = RFID[i, 0] - xTrue[0, 0]\n        dy = RFID[i, 1] - xTrue[1, 0]\n        d = math.hypot(dx, dy)\n        angle = pi_2_pi(math.atan2(dy, dx) - xTrue[2, 0])\n        if d <= MAX_RANGE:",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "motion_model",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def motion_model(x, u):\n    F = np.array([[1.0, 0, 0],\n                  [0, 1.0, 0],\n                  [0, 0, 1.0]])\n    B = np.array([[DT * math.cos(x[2, 0]), 0],\n                  [DT * math.sin(x[2, 0]), 0],\n                  [0.0, DT]])\n    x = (F @ x) + (B @ u)\n    return x\ndef calc_n_lm(x):",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "calc_n_lm",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def calc_n_lm(x):\n    n = int((len(x) - STATE_SIZE) / LM_SIZE)\n    return n\ndef jacob_motion(x, u):\n    Fx = np.hstack((np.eye(STATE_SIZE), np.zeros(\n        (STATE_SIZE, LM_SIZE * calc_n_lm(x)))))\n    jF = np.array([[0.0, 0.0, -DT * u[0, 0] * math.sin(x[2, 0])],\n                   [0.0, 0.0, DT * u[0, 0] * math.cos(x[2, 0])],\n                   [0.0, 0.0, 0.0]], dtype=float)\n    G = np.eye(len(x)) + Fx.T @ jF @ Fx",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "jacob_motion",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def jacob_motion(x, u):\n    Fx = np.hstack((np.eye(STATE_SIZE), np.zeros(\n        (STATE_SIZE, LM_SIZE * calc_n_lm(x)))))\n    jF = np.array([[0.0, 0.0, -DT * u[0, 0] * math.sin(x[2, 0])],\n                   [0.0, 0.0, DT * u[0, 0] * math.cos(x[2, 0])],\n                   [0.0, 0.0, 0.0]], dtype=float)\n    G = np.eye(len(x)) + Fx.T @ jF @ Fx\n    return G, Fx,\ndef calc_landmark_position(x, z):\n    zp = np.zeros((2, 1))",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "calc_landmark_position",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def calc_landmark_position(x, z):\n    zp = np.zeros((2, 1))\n    zp[0, 0] = x[0, 0] + z[0] * math.cos(x[2, 0] + z[1])\n    zp[1, 0] = x[1, 0] + z[0] * math.sin(x[2, 0] + z[1])\n    return zp\ndef get_landmark_position_from_state(x, ind):\n    lm = x[STATE_SIZE + LM_SIZE * ind: STATE_SIZE + LM_SIZE * (ind + 1), :]\n    return lm\ndef search_correspond_landmark_id(xAug, PAug, zi):\n    \"\"\"",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "get_landmark_position_from_state",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def get_landmark_position_from_state(x, ind):\n    lm = x[STATE_SIZE + LM_SIZE * ind: STATE_SIZE + LM_SIZE * (ind + 1), :]\n    return lm\ndef search_correspond_landmark_id(xAug, PAug, zi):\n    \"\"\"\n    Landmark association with Mahalanobis distance\n    \"\"\"\n    nLM = calc_n_lm(xAug)\n    min_dist = []\n    for i in range(nLM):",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "search_correspond_landmark_id",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def search_correspond_landmark_id(xAug, PAug, zi):\n    \"\"\"\n    Landmark association with Mahalanobis distance\n    \"\"\"\n    nLM = calc_n_lm(xAug)\n    min_dist = []\n    for i in range(nLM):\n        lm = get_landmark_position_from_state(xAug, i)\n        y, S, H = calc_innovation(lm, xAug, PAug, zi, i)\n        min_dist.append(y.T @ np.linalg.inv(S) @ y)",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "calc_innovation",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def calc_innovation(lm, xEst, PEst, z, LMid):\n    delta = lm - xEst[0:2]\n    q = (delta.T @ delta)[0, 0]\n    z_angle = math.atan2(delta[1, 0], delta[0, 0]) - xEst[2, 0]\n    zp = np.array([[math.sqrt(q), pi_2_pi(z_angle)]])\n    y = (z - zp).T\n    y[1] = pi_2_pi(y[1])\n    H = jacob_h(q, delta, xEst, LMid + 1)\n    S = H @ PEst @ H.T + Cx[0:2, 0:2]\n    return y, S, H",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "jacob_h",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def jacob_h(q, delta, x, i):\n    sq = math.sqrt(q)\n    G = np.array([[-sq * delta[0, 0], - sq * delta[1, 0], 0, sq * delta[0, 0], sq * delta[1, 0]],\n                  [delta[1, 0], - delta[0, 0], - q, - delta[1, 0], delta[0, 0]]])\n    G = G / q\n    nLM = calc_n_lm(x)\n    F1 = np.hstack((np.eye(3), np.zeros((3, 2 * nLM))))\n    F2 = np.hstack((np.zeros((2, 3)), np.zeros((2, 2 * (i - 1))),\n                    np.eye(2), np.zeros((2, 2 * nLM - 2 * i))))\n    F = np.vstack((F1, F2))",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "pi_2_pi",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def pi_2_pi(angle):\n    return angle_mod(angle)\ndef main():\n    print(__file__ + \" start!!\")\n    time = 0.0\n    # RFID positions [x, y]\n    RFID = np.array([[10.0, -2.0],\n                     [15.0, 10.0],\n                     [3.0, 15.0],\n                     [-5.0, 20.0]])",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "def main():\n    print(__file__ + \" start!!\")\n    time = 0.0\n    # RFID positions [x, y]\n    RFID = np.array([[10.0, -2.0],\n                     [15.0, 10.0],\n                     [3.0, 15.0],\n                     [-5.0, 20.0]])\n    # State Vector [x y yaw v]'\n    xEst = np.zeros((STATE_SIZE, 1))",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "Cx",
        "kind": 5,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "Cx = np.diag([0.5, 0.5, np.deg2rad(30.0)]) ** 2\n#  Simulation parameter\nQ_sim = np.diag([0.2, np.deg2rad(1.0)]) ** 2\nR_sim = np.diag([1.0, np.deg2rad(10.0)]) ** 2\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "Q_sim",
        "kind": 5,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "Q_sim = np.diag([0.2, np.deg2rad(1.0)]) ** 2\nR_sim = np.diag([1.0, np.deg2rad(10.0)]) ** 2\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nshow_animation = True\ndef ekf_slam(xEst, PEst, u, z):",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "R_sim",
        "kind": 5,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "R_sim = np.diag([1.0, np.deg2rad(10.0)]) ** 2\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nshow_animation = True\ndef ekf_slam(xEst, PEst, u, z):\n    # Predict",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "DT",
        "kind": 5,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "DT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nshow_animation = True\ndef ekf_slam(xEst, PEst, u, z):\n    # Predict\n    G, Fx = jacob_motion(xEst, u)",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "SIM_TIME",
        "kind": 5,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "SIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nshow_animation = True\ndef ekf_slam(xEst, PEst, u, z):\n    # Predict\n    G, Fx = jacob_motion(xEst, u)\n    xEst[0:STATE_SIZE] = motion_model(xEst[0:STATE_SIZE], u)",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "MAX_RANGE",
        "kind": 5,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "MAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nshow_animation = True\ndef ekf_slam(xEst, PEst, u, z):\n    # Predict\n    G, Fx = jacob_motion(xEst, u)\n    xEst[0:STATE_SIZE] = motion_model(xEst[0:STATE_SIZE], u)\n    PEst = G.T @ PEst @ G + Fx.T @ Cx @ Fx",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "M_DIST_TH",
        "kind": 5,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "M_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nshow_animation = True\ndef ekf_slam(xEst, PEst, u, z):\n    # Predict\n    G, Fx = jacob_motion(xEst, u)\n    xEst[0:STATE_SIZE] = motion_model(xEst[0:STATE_SIZE], u)\n    PEst = G.T @ PEst @ G + Fx.T @ Cx @ Fx\n    initP = np.eye(2)",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "STATE_SIZE",
        "kind": 5,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "STATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nshow_animation = True\ndef ekf_slam(xEst, PEst, u, z):\n    # Predict\n    G, Fx = jacob_motion(xEst, u)\n    xEst[0:STATE_SIZE] = motion_model(xEst[0:STATE_SIZE], u)\n    PEst = G.T @ PEst @ G + Fx.T @ Cx @ Fx\n    initP = np.eye(2)\n    # Update",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "LM_SIZE",
        "kind": 5,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "LM_SIZE = 2  # LM state size [x,y]\nshow_animation = True\ndef ekf_slam(xEst, PEst, u, z):\n    # Predict\n    G, Fx = jacob_motion(xEst, u)\n    xEst[0:STATE_SIZE] = motion_model(xEst[0:STATE_SIZE], u)\n    PEst = G.T @ PEst @ G + Fx.T @ Cx @ Fx\n    initP = np.eye(2)\n    # Update\n    for iz in range(len(z[:, 0])):  # for each observation",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "SLAM.EKFSLAM.ekf_slam",
        "description": "SLAM.EKFSLAM.ekf_slam",
        "peekOfCode": "show_animation = True\ndef ekf_slam(xEst, PEst, u, z):\n    # Predict\n    G, Fx = jacob_motion(xEst, u)\n    xEst[0:STATE_SIZE] = motion_model(xEst[0:STATE_SIZE], u)\n    PEst = G.T @ PEst @ G + Fx.T @ Cx @ Fx\n    initP = np.eye(2)\n    # Update\n    for iz in range(len(z[:, 0])):  # for each observation\n        min_id = search_correspond_landmark_id(xEst, PEst, z[iz, 0:2])",
        "detail": "SLAM.EKFSLAM.ekf_slam",
        "documentation": {}
    },
    {
        "label": "Particle",
        "kind": 6,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "class Particle:\n    def __init__(self, n_landmark):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0\n        self.y = 0.0\n        self.yaw = 0.0\n        # landmark x-y positions\n        self.lm = np.zeros((n_landmark, LM_SIZE))\n        # landmark position covariance\n        self.lmP = np.zeros((n_landmark * LM_SIZE, LM_SIZE))",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "fast_slam1",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def fast_slam1(particles, u, z):\n    particles = predict_particles(particles, u)\n    particles = update_with_observation(particles, z)\n    particles = resampling(particles)\n    return particles\ndef normalize_weight(particles):\n    sum_w = sum([p.w for p in particles])\n    try:\n        for i in range(N_PARTICLE):\n            particles[i].w /= sum_w",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "normalize_weight",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def normalize_weight(particles):\n    sum_w = sum([p.w for p in particles])\n    try:\n        for i in range(N_PARTICLE):\n            particles[i].w /= sum_w\n    except ZeroDivisionError:\n        for i in range(N_PARTICLE):\n            particles[i].w = 1.0 / N_PARTICLE\n        return particles\n    return particles",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "calc_final_state",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def calc_final_state(particles):\n    xEst = np.zeros((STATE_SIZE, 1))\n    particles = normalize_weight(particles)\n    for i in range(N_PARTICLE):\n        xEst[0, 0] += particles[i].w * particles[i].x\n        xEst[1, 0] += particles[i].w * particles[i].y\n        xEst[2, 0] += particles[i].w * particles[i].yaw\n    xEst[2, 0] = pi_2_pi(xEst[2, 0])\n    #  print(xEst)\n    return xEst",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "predict_particles",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def predict_particles(particles, u):\n    for i in range(N_PARTICLE):\n        px = np.zeros((STATE_SIZE, 1))\n        px[0, 0] = particles[i].x\n        px[1, 0] = particles[i].y\n        px[2, 0] = particles[i].yaw\n        ud = u + (np.random.randn(1, 2) @ R ** 0.5).T  # add noise\n        px = motion_model(px, ud)\n        particles[i].x = px[0, 0]\n        particles[i].y = px[1, 0]",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "add_new_landmark",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def add_new_landmark(particle, z, Q_cov):\n    r = z[0]\n    b = z[1]\n    lm_id = int(z[2])\n    s = math.sin(pi_2_pi(particle.yaw + b))\n    c = math.cos(pi_2_pi(particle.yaw + b))\n    particle.lm[lm_id, 0] = particle.x + r * c\n    particle.lm[lm_id, 1] = particle.y + r * s\n    # covariance\n    dx = r * c",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "compute_jacobians",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def compute_jacobians(particle, xf, Pf, Q_cov):\n    dx = xf[0, 0] - particle.x\n    dy = xf[1, 0] - particle.y\n    d2 = dx ** 2 + dy ** 2\n    d = math.sqrt(d2)\n    zp = np.array(\n        [d, pi_2_pi(math.atan2(dy, dx) - particle.yaw)]).reshape(2, 1)\n    Hv = np.array([[-dx / d, -dy / d, 0.0],\n                   [dy / d2, -dx / d2, -1.0]])\n    Hf = np.array([[dx / d, dy / d],",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "update_kf_with_cholesky",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def update_kf_with_cholesky(xf, Pf, v, Q_cov, Hf):\n    PHt = Pf @ Hf.T\n    S = Hf @ PHt + Q_cov\n    S = (S + S.T) * 0.5\n    s_chol = np.linalg.cholesky(S).T\n    s_chol_inv = np.linalg.inv(s_chol)\n    W1 = PHt @ s_chol_inv\n    W = W1 @ s_chol_inv.T\n    x = xf + W @ v\n    P = Pf - W1 @ W1.T",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "update_landmark",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def update_landmark(particle, z, Q_cov):\n    lm_id = int(z[2])\n    xf = np.array(particle.lm[lm_id, :]).reshape(2, 1)\n    Pf = np.array(particle.lmP[2 * lm_id:2 * lm_id + 2, :])\n    zp, Hv, Hf, Sf = compute_jacobians(particle, xf, Pf, Q)\n    dz = z[0:2].reshape(2, 1) - zp\n    dz[1, 0] = pi_2_pi(dz[1, 0])\n    xf, Pf = update_kf_with_cholesky(xf, Pf, dz, Q_cov, Hf)\n    particle.lm[lm_id, :] = xf.T\n    particle.lmP[2 * lm_id:2 * lm_id + 2, :] = Pf",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "compute_weight",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def compute_weight(particle, z, Q_cov):\n    lm_id = int(z[2])\n    xf = np.array(particle.lm[lm_id, :]).reshape(2, 1)\n    Pf = np.array(particle.lmP[2 * lm_id:2 * lm_id + 2])\n    zp, Hv, Hf, Sf = compute_jacobians(particle, xf, Pf, Q_cov)\n    dx = z[0:2].reshape(2, 1) - zp\n    dx[1, 0] = pi_2_pi(dx[1, 0])\n    try:\n        invS = np.linalg.inv(Sf)\n    except np.linalg.linalg.LinAlgError:",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "update_with_observation",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def update_with_observation(particles, z):\n    for iz in range(len(z[0, :])):\n        landmark_id = int(z[2, iz])\n        for ip in range(N_PARTICLE):\n            # new landmark\n            if abs(particles[ip].lm[landmark_id, 0]) <= 0.01:\n                particles[ip] = add_new_landmark(particles[ip], z[:, iz], Q)\n            # known landmark\n            else:\n                w = compute_weight(particles[ip], z[:, iz], Q)",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "resampling",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def resampling(particles):\n    \"\"\"\n    low variance re-sampling\n    \"\"\"\n    particles = normalize_weight(particles)\n    pw = []\n    for i in range(N_PARTICLE):\n        pw.append(particles[i].w)\n    pw = np.array(pw)\n    n_eff = 1.0 / (pw @ pw.T)  # Effective particle number",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "calc_input",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def calc_input(time):\n    if time <= 3.0:  # wait at first\n        v = 0.0\n        yaw_rate = 0.0\n    else:\n        v = 1.0  # [m/s]\n        yaw_rate = 0.1  # [rad/s]\n    u = np.array([v, yaw_rate]).reshape(2, 1)\n    return u\ndef observation(xTrue, xd, u, rfid):",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "observation",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def observation(xTrue, xd, u, rfid):\n    # calc true state\n    xTrue = motion_model(xTrue, u)\n    # add noise to range observation\n    z = np.zeros((3, 0))\n    for i in range(len(rfid[:, 0])):\n        dx = rfid[i, 0] - xTrue[0, 0]\n        dy = rfid[i, 1] - xTrue[1, 0]\n        d = math.hypot(dx, dy)\n        angle = pi_2_pi(math.atan2(dy, dx) - xTrue[2, 0])",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "motion_model",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def motion_model(x, u):\n    F = np.array([[1.0, 0, 0],\n                  [0, 1.0, 0],\n                  [0, 0, 1.0]])\n    B = np.array([[DT * math.cos(x[2, 0]), 0],\n                  [DT * math.sin(x[2, 0]), 0],\n                  [0.0, DT]])\n    x = F @ x + B @ u\n    x[2, 0] = pi_2_pi(x[2, 0])\n    return x",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "pi_2_pi",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def pi_2_pi(angle):\n    return angle_mod(angle)\ndef main():\n    print(__file__ + \" start!!\")\n    time = 0.0\n    # RFID positions [x, y]\n    RFID = np.array([[10.0, -2.0],\n                     [15.0, 10.0],\n                     [15.0, 15.0],\n                     [10.0, 20.0],",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "def main():\n    print(__file__ + \" start!!\")\n    time = 0.0\n    # RFID positions [x, y]\n    RFID = np.array([[10.0, -2.0],\n                     [15.0, 10.0],\n                     [15.0, 15.0],\n                     [10.0, 20.0],\n                     [3.0, 15.0],\n                     [-5.0, 20.0],",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "Q",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "Q = np.diag([3.0, np.deg2rad(10.0)]) ** 2\nR = np.diag([1.0, np.deg2rad(20.0)]) ** 2\n#  Simulation parameter\nQ_sim = np.diag([0.3, np.deg2rad(2.0)]) ** 2\nR_sim = np.diag([0.5, np.deg2rad(10.0)]) ** 2\nOFFSET_YAW_RATE_NOISE = 0.01\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "R",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "R = np.diag([1.0, np.deg2rad(20.0)]) ** 2\n#  Simulation parameter\nQ_sim = np.diag([0.3, np.deg2rad(2.0)]) ** 2\nR_sim = np.diag([0.5, np.deg2rad(10.0)]) ** 2\nOFFSET_YAW_RATE_NOISE = 0.01\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "Q_sim",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "Q_sim = np.diag([0.3, np.deg2rad(2.0)]) ** 2\nR_sim = np.diag([0.5, np.deg2rad(10.0)]) ** 2\nOFFSET_YAW_RATE_NOISE = 0.01\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "R_sim",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "R_sim = np.diag([0.5, np.deg2rad(10.0)]) ** 2\nOFFSET_YAW_RATE_NOISE = 0.01\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "OFFSET_YAW_RATE_NOISE",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "OFFSET_YAW_RATE_NOISE = 0.01\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "DT",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "DT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "SIM_TIME",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "SIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, n_landmark):",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "MAX_RANGE",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "MAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, n_landmark):\n        self.w = 1.0 / N_PARTICLE",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "M_DIST_TH",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "M_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, n_landmark):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "STATE_SIZE",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "STATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, n_landmark):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0\n        self.y = 0.0",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "LM_SIZE",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "LM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, n_landmark):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0\n        self.y = 0.0\n        self.yaw = 0.0",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "N_PARTICLE",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "N_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, n_landmark):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0\n        self.y = 0.0\n        self.yaw = 0.0\n        # landmark x-y positions",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "NTH",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "NTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, n_landmark):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0\n        self.y = 0.0\n        self.yaw = 0.0\n        # landmark x-y positions\n        self.lm = np.zeros((n_landmark, LM_SIZE))",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "SLAM.FastSLAM1.fast_slam1",
        "description": "SLAM.FastSLAM1.fast_slam1",
        "peekOfCode": "show_animation = True\nclass Particle:\n    def __init__(self, n_landmark):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0\n        self.y = 0.0\n        self.yaw = 0.0\n        # landmark x-y positions\n        self.lm = np.zeros((n_landmark, LM_SIZE))\n        # landmark position covariance",
        "detail": "SLAM.FastSLAM1.fast_slam1",
        "documentation": {}
    },
    {
        "label": "Particle",
        "kind": 6,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "class Particle:\n    def __init__(self, N_LM):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0\n        self.y = 0.0\n        self.yaw = 0.0\n        self.P = np.eye(3)\n        # landmark x-y positions\n        self.lm = np.zeros((N_LM, LM_SIZE))\n        # landmark position covariance",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "fast_slam2",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def fast_slam2(particles, u, z):\n    particles = predict_particles(particles, u)\n    particles = update_with_observation(particles, z)\n    particles = resampling(particles)\n    return particles\ndef normalize_weight(particles):\n    sum_w = sum([p.w for p in particles])\n    try:\n        for i in range(N_PARTICLE):\n            particles[i].w /= sum_w",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "normalize_weight",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def normalize_weight(particles):\n    sum_w = sum([p.w for p in particles])\n    try:\n        for i in range(N_PARTICLE):\n            particles[i].w /= sum_w\n    except ZeroDivisionError:\n        for i in range(N_PARTICLE):\n            particles[i].w = 1.0 / N_PARTICLE\n        return particles\n    return particles",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "calc_final_state",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def calc_final_state(particles):\n    xEst = np.zeros((STATE_SIZE, 1))\n    particles = normalize_weight(particles)\n    for i in range(N_PARTICLE):\n        xEst[0, 0] += particles[i].w * particles[i].x\n        xEst[1, 0] += particles[i].w * particles[i].y\n        xEst[2, 0] += particles[i].w * particles[i].yaw\n    xEst[2, 0] = pi_2_pi(xEst[2, 0])\n    return xEst\ndef predict_particles(particles, u):",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "predict_particles",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def predict_particles(particles, u):\n    for i in range(N_PARTICLE):\n        px = np.zeros((STATE_SIZE, 1))\n        px[0, 0] = particles[i].x\n        px[1, 0] = particles[i].y\n        px[2, 0] = particles[i].yaw\n        ud = u + (np.random.randn(1, 2) @ R ** 0.5).T  # add noise\n        px = motion_model(px, ud)\n        particles[i].x = px[0, 0]\n        particles[i].y = px[1, 0]",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "add_new_lm",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def add_new_lm(particle, z, Q_cov):\n    r = z[0]\n    b = z[1]\n    lm_id = int(z[2])\n    s = math.sin(pi_2_pi(particle.yaw + b))\n    c = math.cos(pi_2_pi(particle.yaw + b))\n    particle.lm[lm_id, 0] = particle.x + r * c\n    particle.lm[lm_id, 1] = particle.y + r * s\n    # covariance\n    dx = r * c",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "compute_jacobians",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def compute_jacobians(particle, xf, Pf, Q_cov):\n    dx = xf[0, 0] - particle.x\n    dy = xf[1, 0] - particle.y\n    d2 = dx ** 2 + dy ** 2\n    d = math.sqrt(d2)\n    zp = np.array(\n        [d, pi_2_pi(math.atan2(dy, dx) - particle.yaw)]).reshape(2, 1)\n    Hv = np.array([[-dx / d, -dy / d, 0.0],\n                   [dy / d2, -dx / d2, -1.0]])\n    Hf = np.array([[dx / d, dy / d],",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "update_kf_with_cholesky",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def update_kf_with_cholesky(xf, Pf, v, Q_cov, Hf):\n    PHt = Pf @ Hf.T\n    S = Hf @ PHt + Q_cov\n    S = (S + S.T) * 0.5\n    SChol = np.linalg.cholesky(S).T\n    SCholInv = np.linalg.inv(SChol)\n    W1 = PHt @ SCholInv\n    W = W1 @ SCholInv.T\n    x = xf + W @ v\n    P = Pf - W1 @ W1.T",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "update_landmark",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def update_landmark(particle, z, Q_cov):\n    lm_id = int(z[2])\n    xf = np.array(particle.lm[lm_id, :]).reshape(2, 1)\n    Pf = np.array(particle.lmP[2 * lm_id:2 * lm_id + 2])\n    zp, Hv, Hf, Sf = compute_jacobians(particle, xf, Pf, Q_cov)\n    dz = z[0:2].reshape(2, 1) - zp\n    dz[1, 0] = pi_2_pi(dz[1, 0])\n    xf, Pf = update_kf_with_cholesky(xf, Pf, dz, Q, Hf)\n    particle.lm[lm_id, :] = xf.T\n    particle.lmP[2 * lm_id:2 * lm_id + 2, :] = Pf",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "compute_weight",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def compute_weight(particle, z, Q_cov):\n    lm_id = int(z[2])\n    xf = np.array(particle.lm[lm_id, :]).reshape(2, 1)\n    Pf = np.array(particle.lmP[2 * lm_id:2 * lm_id + 2])\n    zp, Hv, Hf, Sf = compute_jacobians(particle, xf, Pf, Q_cov)\n    dz = z[0:2].reshape(2, 1) - zp\n    dz[1, 0] = pi_2_pi(dz[1, 0])\n    try:\n        invS = np.linalg.inv(Sf)\n    except np.linalg.linalg.LinAlgError:",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "proposal_sampling",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def proposal_sampling(particle, z, Q_cov):\n    lm_id = int(z[2])\n    xf = particle.lm[lm_id, :].reshape(2, 1)\n    Pf = particle.lmP[2 * lm_id:2 * lm_id + 2]\n    # State\n    x = np.array([particle.x, particle.y, particle.yaw]).reshape(3, 1)\n    P = particle.P\n    zp, Hv, Hf, Sf = compute_jacobians(particle, xf, Pf, Q_cov)\n    Sfi = np.linalg.inv(Sf)\n    dz = z[0:2].reshape(2, 1) - zp",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "update_with_observation",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def update_with_observation(particles, z):\n    for iz in range(len(z[0, :])):\n        landmark_id = int(z[2, iz])\n        for ip in range(N_PARTICLE):\n            # new landmark\n            if abs(particles[ip].lm[landmark_id, 0]) <= 0.01:\n                particles[ip] = add_new_lm(particles[ip], z[:, iz], Q)\n            # known landmark\n            else:\n                w = compute_weight(particles[ip], z[:, iz], Q)",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "resampling",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def resampling(particles):\n    \"\"\"\n    low variance re-sampling\n    \"\"\"\n    particles = normalize_weight(particles)\n    pw = []\n    for i in range(N_PARTICLE):\n        pw.append(particles[i].w)\n    pw = np.array(pw)\n    n_eff = 1.0 / (pw @ pw.T)  # Effective particle number",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "calc_input",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def calc_input(time):\n    if time <= 3.0:  # wait at first\n        v = 0.0\n        yaw_rate = 0.0\n    else:\n        v = 1.0  # [m/s]\n        yaw_rate = 0.1  # [rad/s]\n    u = np.array([v, yaw_rate]).reshape(2, 1)\n    return u\ndef observation(xTrue, xd, u, RFID):",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "observation",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def observation(xTrue, xd, u, RFID):\n    # calc true state\n    xTrue = motion_model(xTrue, u)\n    # add noise to range observation\n    z = np.zeros((3, 0))\n    for i in range(len(RFID[:, 0])):\n        dx = RFID[i, 0] - xTrue[0, 0]\n        dy = RFID[i, 1] - xTrue[1, 0]\n        d = math.hypot(dx, dy)\n        angle = pi_2_pi(math.atan2(dy, dx) - xTrue[2, 0])",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "motion_model",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def motion_model(x, u):\n    F = np.array([[1.0, 0, 0],\n                  [0, 1.0, 0],\n                  [0, 0, 1.0]])\n    B = np.array([[DT * math.cos(x[2, 0]), 0],\n                  [DT * math.sin(x[2, 0]), 0],\n                  [0.0, DT]])\n    x = F @ x + B @ u\n    x[2, 0] = pi_2_pi(x[2, 0])\n    return x",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "pi_2_pi",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def pi_2_pi(angle):\n    return angle_mod(angle)\ndef main():\n    print(__file__ + \" start!!\")\n    time = 0.0\n    # RFID positions [x, y]\n    RFID = np.array([[10.0, -2.0],\n                     [15.0, 10.0],\n                     [15.0, 15.0],\n                     [10.0, 20.0],",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "def main():\n    print(__file__ + \" start!!\")\n    time = 0.0\n    # RFID positions [x, y]\n    RFID = np.array([[10.0, -2.0],\n                     [15.0, 10.0],\n                     [15.0, 15.0],\n                     [10.0, 20.0],\n                     [3.0, 15.0],\n                     [-5.0, 20.0],",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "Q",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "Q = np.diag([3.0, np.deg2rad(10.0)]) ** 2\nR = np.diag([1.0, np.deg2rad(20.0)]) ** 2\n#  Simulation parameter\nQ_sim = np.diag([0.3, np.deg2rad(2.0)]) ** 2\nR_sim = np.diag([0.5, np.deg2rad(10.0)]) ** 2\nOFFSET_YAW_RATE_NOISE = 0.01\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "R",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "R = np.diag([1.0, np.deg2rad(20.0)]) ** 2\n#  Simulation parameter\nQ_sim = np.diag([0.3, np.deg2rad(2.0)]) ** 2\nR_sim = np.diag([0.5, np.deg2rad(10.0)]) ** 2\nOFFSET_YAW_RATE_NOISE = 0.01\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "Q_sim",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "Q_sim = np.diag([0.3, np.deg2rad(2.0)]) ** 2\nR_sim = np.diag([0.5, np.deg2rad(10.0)]) ** 2\nOFFSET_YAW_RATE_NOISE = 0.01\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "R_sim",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "R_sim = np.diag([0.5, np.deg2rad(10.0)]) ** 2\nOFFSET_YAW_RATE_NOISE = 0.01\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "OFFSET_YAW_RATE_NOISE",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "OFFSET_YAW_RATE_NOISE = 0.01\nDT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "DT",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "DT = 0.1  # time tick [s]\nSIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "SIM_TIME",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "SIM_TIME = 50.0  # simulation time [s]\nMAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, N_LM):",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "MAX_RANGE",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "MAX_RANGE = 20.0  # maximum observation range\nM_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, N_LM):\n        self.w = 1.0 / N_PARTICLE",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "M_DIST_TH",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "M_DIST_TH = 2.0  # Threshold of Mahalanobis distance for data association.\nSTATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, N_LM):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "STATE_SIZE",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "STATE_SIZE = 3  # State size [x,y,yaw]\nLM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, N_LM):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0\n        self.y = 0.0",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "LM_SIZE",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "LM_SIZE = 2  # LM state size [x,y]\nN_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, N_LM):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0\n        self.y = 0.0\n        self.yaw = 0.0",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "N_PARTICLE",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "N_PARTICLE = 100  # number of particle\nNTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, N_LM):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0\n        self.y = 0.0\n        self.yaw = 0.0\n        self.P = np.eye(3)",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "NTH",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "NTH = N_PARTICLE / 1.5  # Number of particle for re-sampling\nshow_animation = True\nclass Particle:\n    def __init__(self, N_LM):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0\n        self.y = 0.0\n        self.yaw = 0.0\n        self.P = np.eye(3)\n        # landmark x-y positions",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "SLAM.FastSLAM2.fast_slam2",
        "description": "SLAM.FastSLAM2.fast_slam2",
        "peekOfCode": "show_animation = True\nclass Particle:\n    def __init__(self, N_LM):\n        self.w = 1.0 / N_PARTICLE\n        self.x = 0.0\n        self.y = 0.0\n        self.yaw = 0.0\n        self.P = np.eye(3)\n        # landmark x-y positions\n        self.lm = np.zeros((N_LM, LM_SIZE))",
        "detail": "SLAM.FastSLAM2.fast_slam2",
        "documentation": {}
    },
    {
        "label": "EdgeOdometry",
        "kind": 6,
        "importPath": "SLAM.GraphBasedSLAM.graphslam.edge.edge_odometry",
        "description": "SLAM.GraphBasedSLAM.graphslam.edge.edge_odometry",
        "peekOfCode": "class EdgeOdometry:\n    r\"\"\"A class for representing odometry edges in Graph SLAM.\n    Parameters\n    ----------\n    vertices : list[graphslam.vertex.Vertex]\n        A list of the vertices constrained by the edge\n    information : np.ndarray\n        The information matrix :math:`\\Omega_j` associated with the edge\n    estimate : graphslam.pose.se2.PoseSE2\n        The expected measurement :math:`\\mathbf{z}_j`",
        "detail": "SLAM.GraphBasedSLAM.graphslam.edge.edge_odometry",
        "documentation": {}
    },
    {
        "label": "EPSILON",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graphslam.edge.edge_odometry",
        "description": "SLAM.GraphBasedSLAM.graphslam.edge.edge_odometry",
        "peekOfCode": "EPSILON = 1e-6\nclass EdgeOdometry:\n    r\"\"\"A class for representing odometry edges in Graph SLAM.\n    Parameters\n    ----------\n    vertices : list[graphslam.vertex.Vertex]\n        A list of the vertices constrained by the edge\n    information : np.ndarray\n        The information matrix :math:`\\Omega_j` associated with the edge\n    estimate : graphslam.pose.se2.PoseSE2",
        "detail": "SLAM.GraphBasedSLAM.graphslam.edge.edge_odometry",
        "documentation": {}
    },
    {
        "label": "PoseSE2",
        "kind": 6,
        "importPath": "SLAM.GraphBasedSLAM.graphslam.pose.se2",
        "description": "SLAM.GraphBasedSLAM.graphslam.pose.se2",
        "peekOfCode": "class PoseSE2(np.ndarray):\n    r\"\"\"A representation of a pose in :math:`SE(2)`.\n    Parameters\n    ----------\n    position : np.ndarray, list\n        The position in :math:`\\mathbb{R}^2`\n    orientation : float\n        The angle of the pose (in radians)\n    \"\"\"\n    def __new__(cls, position, orientation):",
        "detail": "SLAM.GraphBasedSLAM.graphslam.pose.se2",
        "documentation": {}
    },
    {
        "label": "_Chi2GradientHessian",
        "kind": 6,
        "importPath": "SLAM.GraphBasedSLAM.graphslam.graph",
        "description": "SLAM.GraphBasedSLAM.graphslam.graph",
        "peekOfCode": "class _Chi2GradientHessian:\n    r\"\"\"A class that is used to aggregate the :math:`\\chi^2` error, gradient, and Hessian.\n    Parameters\n    ----------\n    dim : int\n        The compact dimensionality of the poses\n    Attributes\n    ----------\n    chi2 : float\n        The :math:`\\chi^2` error",
        "detail": "SLAM.GraphBasedSLAM.graphslam.graph",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "SLAM.GraphBasedSLAM.graphslam.graph",
        "description": "SLAM.GraphBasedSLAM.graphslam.graph",
        "peekOfCode": "class Graph(object):\n    r\"\"\"A graph that will be optimized via Graph SLAM.\n    Parameters\n    ----------\n    edges : list[graphslam.edge.edge_odometry.EdgeOdometry]\n        A list of the vertices in the graph\n    vertices : list[graphslam.vertex.Vertex]\n        A list of the vertices in the graph\n    Attributes\n    ----------",
        "detail": "SLAM.GraphBasedSLAM.graphslam.graph",
        "documentation": {}
    },
    {
        "label": "load_g2o_se2",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graphslam.load",
        "description": "SLAM.GraphBasedSLAM.graphslam.load",
        "peekOfCode": "def load_g2o_se2(infile):\n    \"\"\"Load an :math:`SE(2)` graph from a .g2o file.\n    Parameters\n    ----------\n    infile : str\n        The path to the .g2o file\n    Returns\n    -------\n    Graph\n        The loaded graph",
        "detail": "SLAM.GraphBasedSLAM.graphslam.load",
        "documentation": {}
    },
    {
        "label": "_LOGGER",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graphslam.load",
        "description": "SLAM.GraphBasedSLAM.graphslam.load",
        "peekOfCode": "_LOGGER = logging.getLogger(__name__)\ndef load_g2o_se2(infile):\n    \"\"\"Load an :math:`SE(2)` graph from a .g2o file.\n    Parameters\n    ----------\n    infile : str\n        The path to the .g2o file\n    Returns\n    -------\n    Graph",
        "detail": "SLAM.GraphBasedSLAM.graphslam.load",
        "documentation": {}
    },
    {
        "label": "neg_pi_to_pi",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graphslam.util",
        "description": "SLAM.GraphBasedSLAM.graphslam.util",
        "peekOfCode": "def neg_pi_to_pi(angle):\n    r\"\"\"Normalize ``angle`` to be in :math:`[-\\pi, \\pi)`.\n    Parameters\n    ----------\n    angle : float\n        An angle (in radians)\n    Returns\n    -------\n    float\n        The angle normalized to :math:`[-\\pi, \\pi)`",
        "detail": "SLAM.GraphBasedSLAM.graphslam.util",
        "documentation": {}
    },
    {
        "label": "solve_for_edge_dimensionality",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graphslam.util",
        "description": "SLAM.GraphBasedSLAM.graphslam.util",
        "peekOfCode": "def solve_for_edge_dimensionality(n):\n    r\"\"\"Solve for the dimensionality of an edge.\n    In a .g2o file, an edge is specified as ``<estimate> <information matrix>``, where only the upper triangular portion of the matrix is provided.\n    This solves the problem:\n    .. math::\n       d + \\frac{d (d + 1)}{2} = n\n    Returns\n    -------\n    int\n        The dimensionality of the edge",
        "detail": "SLAM.GraphBasedSLAM.graphslam.util",
        "documentation": {}
    },
    {
        "label": "upper_triangular_matrix_to_full_matrix",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graphslam.util",
        "description": "SLAM.GraphBasedSLAM.graphslam.util",
        "peekOfCode": "def upper_triangular_matrix_to_full_matrix(arr, n):\n    \"\"\"Given an upper triangular matrix, return the full matrix.\n    Parameters\n    ----------\n    arr : np.ndarray\n        The upper triangular portion of the matrix\n    n : int\n        The size of the matrix\n    Returns\n    -------",
        "detail": "SLAM.GraphBasedSLAM.graphslam.util",
        "documentation": {}
    },
    {
        "label": "TWO_PI",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graphslam.util",
        "description": "SLAM.GraphBasedSLAM.graphslam.util",
        "peekOfCode": "TWO_PI = 2 * np.pi\ndef neg_pi_to_pi(angle):\n    r\"\"\"Normalize ``angle`` to be in :math:`[-\\pi, \\pi)`.\n    Parameters\n    ----------\n    angle : float\n        An angle (in radians)\n    Returns\n    -------\n    float",
        "detail": "SLAM.GraphBasedSLAM.graphslam.util",
        "documentation": {}
    },
    {
        "label": "Vertex",
        "kind": 6,
        "importPath": "SLAM.GraphBasedSLAM.graphslam.vertex",
        "description": "SLAM.GraphBasedSLAM.graphslam.vertex",
        "peekOfCode": "class Vertex:\n    \"\"\"A class for representing a vertex in Graph SLAM.\n    Parameters\n    ----------\n    vertex_id : int\n        The vertex's unique ID\n    pose : graphslam.pose.se2.PoseSE2\n        The pose associated with the vertex\n    vertex_index : int, None\n        The vertex's index in the graph's ``vertices`` list",
        "detail": "SLAM.GraphBasedSLAM.graphslam.vertex",
        "documentation": {}
    },
    {
        "label": "Edge",
        "kind": 6,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "class Edge:\n    def __init__(self):\n        self.e = np.zeros((3, 1))\n        self.omega = np.zeros((3, 3))  # information matrix\n        self.d1 = 0.0\n        self.d2 = 0.0\n        self.yaw1 = 0.0\n        self.yaw2 = 0.0\n        self.angle1 = 0.0\n        self.angle2 = 0.0",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "cal_observation_sigma",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "def cal_observation_sigma():\n    sigma = np.zeros((3, 3))\n    sigma[0, 0] = C_SIGMA1 ** 2\n    sigma[1, 1] = C_SIGMA2 ** 2\n    sigma[2, 2] = C_SIGMA3 ** 2\n    return sigma\ndef calc_3d_rotational_matrix(angle):\n    return Rot.from_euler('z', angle).as_matrix()\ndef calc_edge(x1, y1, yaw1, x2, y2, yaw2, d1,\n              angle1, d2, angle2, t1, t2):",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "calc_3d_rotational_matrix",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "def calc_3d_rotational_matrix(angle):\n    return Rot.from_euler('z', angle).as_matrix()\ndef calc_edge(x1, y1, yaw1, x2, y2, yaw2, d1,\n              angle1, d2, angle2, t1, t2):\n    edge = Edge()\n    tangle1 = pi_2_pi(yaw1 + angle1)\n    tangle2 = pi_2_pi(yaw2 + angle2)\n    tmp1 = d1 * math.cos(tangle1)\n    tmp2 = d2 * math.cos(tangle2)\n    tmp3 = d1 * math.sin(tangle1)",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "calc_edge",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "def calc_edge(x1, y1, yaw1, x2, y2, yaw2, d1,\n              angle1, d2, angle2, t1, t2):\n    edge = Edge()\n    tangle1 = pi_2_pi(yaw1 + angle1)\n    tangle2 = pi_2_pi(yaw2 + angle2)\n    tmp1 = d1 * math.cos(tangle1)\n    tmp2 = d2 * math.cos(tangle2)\n    tmp3 = d1 * math.sin(tangle1)\n    tmp4 = d2 * math.sin(tangle2)\n    edge.e[0, 0] = x2 - x1 - tmp1 + tmp2",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "calc_edges",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "def calc_edges(x_list, z_list):\n    edges = []\n    cost = 0.0\n    z_ids = list(itertools.combinations(range(len(z_list)), 2))\n    for (t1, t2) in z_ids:\n        x1, y1, yaw1 = x_list[0, t1], x_list[1, t1], x_list[2, t1]\n        x2, y2, yaw2 = x_list[0, t2], x_list[1, t2], x_list[2, t2]\n        if z_list[t1] is None or z_list[t2] is None:\n            continue  # No observation\n        for iz1 in range(len(z_list[t1][:, 0])):",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "calc_jacobian",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "def calc_jacobian(edge):\n    t1 = edge.yaw1 + edge.angle1\n    A = np.array([[-1.0, 0, edge.d1 * math.sin(t1)],\n                  [0, -1.0, -edge.d1 * math.cos(t1)],\n                  [0, 0, 0]])\n    t2 = edge.yaw2 + edge.angle2\n    B = np.array([[1.0, 0, -edge.d2 * math.sin(t2)],\n                  [0, 1.0, edge.d2 * math.cos(t2)],\n                  [0, 0, 0]])\n    return A, B",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "fill_H_and_b",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "def fill_H_and_b(H, b, edge):\n    A, B = calc_jacobian(edge)\n    id1 = edge.id1 * STATE_SIZE\n    id2 = edge.id2 * STATE_SIZE\n    H[id1:id1 + STATE_SIZE, id1:id1 + STATE_SIZE] += A.T @ edge.omega @ A\n    H[id1:id1 + STATE_SIZE, id2:id2 + STATE_SIZE] += A.T @ edge.omega @ B\n    H[id2:id2 + STATE_SIZE, id1:id1 + STATE_SIZE] += B.T @ edge.omega @ A\n    H[id2:id2 + STATE_SIZE, id2:id2 + STATE_SIZE] += B.T @ edge.omega @ B\n    b[id1:id1 + STATE_SIZE] += (A.T @ edge.omega @ edge.e)\n    b[id2:id2 + STATE_SIZE] += (B.T @ edge.omega @ edge.e)",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "graph_based_slam",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "def graph_based_slam(x_init, hz):\n    print(\"start graph based slam\")\n    z_list = copy.deepcopy(hz)\n    x_opt = copy.deepcopy(x_init)\n    nt = x_opt.shape[1]\n    n = nt * STATE_SIZE\n    for itr in range(MAX_ITR):\n        edges = calc_edges(x_opt, z_list)\n        H = np.zeros((n, n))\n        b = np.zeros((n, 1))",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "calc_input",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "def calc_input():\n    v = 1.0  # [m/s]\n    yaw_rate = 0.1  # [rad/s]\n    u = np.array([[v, yaw_rate]]).T\n    return u\ndef observation(xTrue, xd, u, RFID):\n    xTrue = motion_model(xTrue, u)\n    # add noise to gps x-y\n    z = np.zeros((0, 4))\n    for i in range(len(RFID[:, 0])):",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "observation",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "def observation(xTrue, xd, u, RFID):\n    xTrue = motion_model(xTrue, u)\n    # add noise to gps x-y\n    z = np.zeros((0, 4))\n    for i in range(len(RFID[:, 0])):\n        dx = RFID[i, 0] - xTrue[0, 0]\n        dy = RFID[i, 1] - xTrue[1, 0]\n        d = math.hypot(dx, dy)\n        angle = pi_2_pi(math.atan2(dy, dx)) - xTrue[2, 0]\n        phi = pi_2_pi(math.atan2(dy, dx))",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "motion_model",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "def motion_model(x, u):\n    F = np.array([[1.0, 0, 0],\n                  [0, 1.0, 0],\n                  [0, 0, 1.0]])\n    B = np.array([[DT * math.cos(x[2, 0]), 0],\n                  [DT * math.sin(x[2, 0]), 0],\n                  [0.0, DT]])\n    x = F @ x + B @ u\n    return x\ndef pi_2_pi(angle):",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "pi_2_pi",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "def pi_2_pi(angle):\n    return angle_mod(angle)\ndef main():\n    print(__file__ + \" start!!\")\n    time = 0.0\n    # RFID positions [x, y, yaw]\n    RFID = np.array([[10.0, -2.0, 0.0],\n                     [15.0, 10.0, 0.0],\n                     [3.0, 15.0, 0.0],\n                     [-5.0, 20.0, 0.0],",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "def main():\n    print(__file__ + \" start!!\")\n    time = 0.0\n    # RFID positions [x, y, yaw]\n    RFID = np.array([[10.0, -2.0, 0.0],\n                     [15.0, 10.0, 0.0],\n                     [3.0, 15.0, 0.0],\n                     [-5.0, 20.0, 0.0],\n                     [-5.0, 5.0, 0.0]\n                     ])",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "Q_sim",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "Q_sim = np.diag([0.2, np.deg2rad(1.0)]) ** 2\nR_sim = np.diag([0.1, np.deg2rad(10.0)]) ** 2\nDT = 2.0  # time tick [s]\nSIM_TIME = 100.0  # simulation time [s]\nMAX_RANGE = 30.0  # maximum observation range\nSTATE_SIZE = 3  # State size [x,y,yaw]\n# Covariance parameter of Graph Based SLAM\nC_SIGMA1 = 0.1\nC_SIGMA2 = 0.1\nC_SIGMA3 = np.deg2rad(1.0)",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "R_sim",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "R_sim = np.diag([0.1, np.deg2rad(10.0)]) ** 2\nDT = 2.0  # time tick [s]\nSIM_TIME = 100.0  # simulation time [s]\nMAX_RANGE = 30.0  # maximum observation range\nSTATE_SIZE = 3  # State size [x,y,yaw]\n# Covariance parameter of Graph Based SLAM\nC_SIGMA1 = 0.1\nC_SIGMA2 = 0.1\nC_SIGMA3 = np.deg2rad(1.0)\nMAX_ITR = 20  # Maximum iteration",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "DT",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "DT = 2.0  # time tick [s]\nSIM_TIME = 100.0  # simulation time [s]\nMAX_RANGE = 30.0  # maximum observation range\nSTATE_SIZE = 3  # State size [x,y,yaw]\n# Covariance parameter of Graph Based SLAM\nC_SIGMA1 = 0.1\nC_SIGMA2 = 0.1\nC_SIGMA3 = np.deg2rad(1.0)\nMAX_ITR = 20  # Maximum iteration\nshow_graph_d_time = 20.0  # [s]",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "SIM_TIME",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "SIM_TIME = 100.0  # simulation time [s]\nMAX_RANGE = 30.0  # maximum observation range\nSTATE_SIZE = 3  # State size [x,y,yaw]\n# Covariance parameter of Graph Based SLAM\nC_SIGMA1 = 0.1\nC_SIGMA2 = 0.1\nC_SIGMA3 = np.deg2rad(1.0)\nMAX_ITR = 20  # Maximum iteration\nshow_graph_d_time = 20.0  # [s]\nshow_animation = True",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "MAX_RANGE",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "MAX_RANGE = 30.0  # maximum observation range\nSTATE_SIZE = 3  # State size [x,y,yaw]\n# Covariance parameter of Graph Based SLAM\nC_SIGMA1 = 0.1\nC_SIGMA2 = 0.1\nC_SIGMA3 = np.deg2rad(1.0)\nMAX_ITR = 20  # Maximum iteration\nshow_graph_d_time = 20.0  # [s]\nshow_animation = True\nclass Edge:",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "STATE_SIZE",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "STATE_SIZE = 3  # State size [x,y,yaw]\n# Covariance parameter of Graph Based SLAM\nC_SIGMA1 = 0.1\nC_SIGMA2 = 0.1\nC_SIGMA3 = np.deg2rad(1.0)\nMAX_ITR = 20  # Maximum iteration\nshow_graph_d_time = 20.0  # [s]\nshow_animation = True\nclass Edge:\n    def __init__(self):",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "C_SIGMA1",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "C_SIGMA1 = 0.1\nC_SIGMA2 = 0.1\nC_SIGMA3 = np.deg2rad(1.0)\nMAX_ITR = 20  # Maximum iteration\nshow_graph_d_time = 20.0  # [s]\nshow_animation = True\nclass Edge:\n    def __init__(self):\n        self.e = np.zeros((3, 1))\n        self.omega = np.zeros((3, 3))  # information matrix",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "C_SIGMA2",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "C_SIGMA2 = 0.1\nC_SIGMA3 = np.deg2rad(1.0)\nMAX_ITR = 20  # Maximum iteration\nshow_graph_d_time = 20.0  # [s]\nshow_animation = True\nclass Edge:\n    def __init__(self):\n        self.e = np.zeros((3, 1))\n        self.omega = np.zeros((3, 3))  # information matrix\n        self.d1 = 0.0",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "C_SIGMA3",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "C_SIGMA3 = np.deg2rad(1.0)\nMAX_ITR = 20  # Maximum iteration\nshow_graph_d_time = 20.0  # [s]\nshow_animation = True\nclass Edge:\n    def __init__(self):\n        self.e = np.zeros((3, 1))\n        self.omega = np.zeros((3, 3))  # information matrix\n        self.d1 = 0.0\n        self.d2 = 0.0",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "MAX_ITR",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "MAX_ITR = 20  # Maximum iteration\nshow_graph_d_time = 20.0  # [s]\nshow_animation = True\nclass Edge:\n    def __init__(self):\n        self.e = np.zeros((3, 1))\n        self.omega = np.zeros((3, 3))  # information matrix\n        self.d1 = 0.0\n        self.d2 = 0.0\n        self.yaw1 = 0.0",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "show_graph_d_time",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "show_graph_d_time = 20.0  # [s]\nshow_animation = True\nclass Edge:\n    def __init__(self):\n        self.e = np.zeros((3, 1))\n        self.omega = np.zeros((3, 3))  # information matrix\n        self.d1 = 0.0\n        self.d2 = 0.0\n        self.yaw1 = 0.0\n        self.yaw2 = 0.0",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "SLAM.GraphBasedSLAM.graph_based_slam",
        "description": "SLAM.GraphBasedSLAM.graph_based_slam",
        "peekOfCode": "show_animation = True\nclass Edge:\n    def __init__(self):\n        self.e = np.zeros((3, 1))\n        self.omega = np.zeros((3, 3))  # information matrix\n        self.d1 = 0.0\n        self.d2 = 0.0\n        self.yaw1 = 0.0\n        self.yaw2 = 0.0\n        self.angle1 = 0.0",
        "detail": "SLAM.GraphBasedSLAM.graph_based_slam",
        "documentation": {}
    },
    {
        "label": "icp_matching",
        "kind": 2,
        "importPath": "SLAM.iterative_closest_point.iterative_closest_point",
        "description": "SLAM.iterative_closest_point.iterative_closest_point",
        "peekOfCode": "def icp_matching(previous_points, current_points):\n    \"\"\"\n    Iterative Closest Point matching\n    - input\n    previous_points: 2D or 3D points in the previous frame\n    current_points: 2D or 3D points in the current frame\n    - output\n    R: Rotation matrix\n    T: Translation vector\n    \"\"\"",
        "detail": "SLAM.iterative_closest_point.iterative_closest_point",
        "documentation": {}
    },
    {
        "label": "update_homogeneous_matrix",
        "kind": 2,
        "importPath": "SLAM.iterative_closest_point.iterative_closest_point",
        "description": "SLAM.iterative_closest_point.iterative_closest_point",
        "peekOfCode": "def update_homogeneous_matrix(Hin, R, T):\n    r_size = R.shape[0]\n    H = np.zeros((r_size + 1, r_size + 1))\n    H[0:r_size, 0:r_size] = R\n    H[0:r_size, r_size] = T\n    H[r_size, r_size] = 1.0\n    if Hin is None:\n        return H\n    else:\n        return Hin @ H",
        "detail": "SLAM.iterative_closest_point.iterative_closest_point",
        "documentation": {}
    },
    {
        "label": "nearest_neighbor_association",
        "kind": 2,
        "importPath": "SLAM.iterative_closest_point.iterative_closest_point",
        "description": "SLAM.iterative_closest_point.iterative_closest_point",
        "peekOfCode": "def nearest_neighbor_association(previous_points, current_points):\n    # calc the sum of residual errors\n    delta_points = previous_points - current_points\n    d = np.linalg.norm(delta_points, axis=0)\n    error = sum(d)\n    # calc index with nearest neighbor assosiation\n    d = np.linalg.norm(np.repeat(current_points, previous_points.shape[1], axis=1)\n                       - np.tile(previous_points, (1, current_points.shape[1])), axis=0)\n    indexes = np.argmin(d.reshape(current_points.shape[1], previous_points.shape[1]), axis=1)\n    return indexes, error",
        "detail": "SLAM.iterative_closest_point.iterative_closest_point",
        "documentation": {}
    },
    {
        "label": "svd_motion_estimation",
        "kind": 2,
        "importPath": "SLAM.iterative_closest_point.iterative_closest_point",
        "description": "SLAM.iterative_closest_point.iterative_closest_point",
        "peekOfCode": "def svd_motion_estimation(previous_points, current_points):\n    pm = np.mean(previous_points, axis=1)\n    cm = np.mean(current_points, axis=1)\n    p_shift = previous_points - pm[:, np.newaxis]\n    c_shift = current_points - cm[:, np.newaxis]\n    W = c_shift @ p_shift.T\n    u, s, vh = np.linalg.svd(W)\n    R = (u @ vh).T\n    t = pm - (R @ cm)\n    return R, t",
        "detail": "SLAM.iterative_closest_point.iterative_closest_point",
        "documentation": {}
    },
    {
        "label": "plot_points",
        "kind": 2,
        "importPath": "SLAM.iterative_closest_point.iterative_closest_point",
        "description": "SLAM.iterative_closest_point.iterative_closest_point",
        "peekOfCode": "def plot_points(previous_points, current_points, figure):\n    # for stopping simulation with the esc key.\n    plt.gcf().canvas.mpl_connect(\n        'key_release_event',\n        lambda event: [exit(0) if event.key == 'escape' else None])\n    if previous_points.shape[0] == 3:\n        plt.clf()\n        axes = figure.add_subplot(111, projection='3d')\n        axes.scatter(previous_points[0, :], previous_points[1, :],\n                    previous_points[2, :], c=\"r\", marker=\".\")",
        "detail": "SLAM.iterative_closest_point.iterative_closest_point",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "SLAM.iterative_closest_point.iterative_closest_point",
        "description": "SLAM.iterative_closest_point.iterative_closest_point",
        "peekOfCode": "def main():\n    print(__file__ + \" start!!\")\n    # simulation parameters\n    nPoint = 1000\n    fieldLength = 50.0\n    motion = [0.5, 2.0, np.deg2rad(-10.0)]  # movement [x[m],y[m],yaw[deg]]\n    nsim = 3  # number of simulation\n    for _ in range(nsim):\n        # previous points\n        px = (np.random.rand(nPoint) - 0.5) * fieldLength",
        "detail": "SLAM.iterative_closest_point.iterative_closest_point",
        "documentation": {}
    },
    {
        "label": "main_3d_points",
        "kind": 2,
        "importPath": "SLAM.iterative_closest_point.iterative_closest_point",
        "description": "SLAM.iterative_closest_point.iterative_closest_point",
        "peekOfCode": "def main_3d_points():\n    print(__file__ + \" start!!\")\n    # simulation parameters for 3d point set\n    nPoint = 1000\n    fieldLength = 50.0\n    motion = [0.5, 2.0, -5, np.deg2rad(-10.0)]  # [x[m],y[m],z[m],roll[deg]]\n    nsim = 3  # number of simulation\n    for _ in range(nsim):\n        # previous points\n        px = (np.random.rand(nPoint) - 0.5) * fieldLength",
        "detail": "SLAM.iterative_closest_point.iterative_closest_point",
        "documentation": {}
    },
    {
        "label": "EPS",
        "kind": 5,
        "importPath": "SLAM.iterative_closest_point.iterative_closest_point",
        "description": "SLAM.iterative_closest_point.iterative_closest_point",
        "peekOfCode": "EPS = 0.0001\nMAX_ITER = 100\nshow_animation = True\ndef icp_matching(previous_points, current_points):\n    \"\"\"\n    Iterative Closest Point matching\n    - input\n    previous_points: 2D or 3D points in the previous frame\n    current_points: 2D or 3D points in the current frame\n    - output",
        "detail": "SLAM.iterative_closest_point.iterative_closest_point",
        "documentation": {}
    },
    {
        "label": "MAX_ITER",
        "kind": 5,
        "importPath": "SLAM.iterative_closest_point.iterative_closest_point",
        "description": "SLAM.iterative_closest_point.iterative_closest_point",
        "peekOfCode": "MAX_ITER = 100\nshow_animation = True\ndef icp_matching(previous_points, current_points):\n    \"\"\"\n    Iterative Closest Point matching\n    - input\n    previous_points: 2D or 3D points in the previous frame\n    current_points: 2D or 3D points in the current frame\n    - output\n    R: Rotation matrix",
        "detail": "SLAM.iterative_closest_point.iterative_closest_point",
        "documentation": {}
    },
    {
        "label": "show_animation",
        "kind": 5,
        "importPath": "SLAM.iterative_closest_point.iterative_closest_point",
        "description": "SLAM.iterative_closest_point.iterative_closest_point",
        "peekOfCode": "show_animation = True\ndef icp_matching(previous_points, current_points):\n    \"\"\"\n    Iterative Closest Point matching\n    - input\n    previous_points: 2D or 3D points in the previous frame\n    current_points: 2D or 3D points in the current frame\n    - output\n    R: Rotation matrix\n    T: Translation vector",
        "detail": "SLAM.iterative_closest_point.iterative_closest_point",
        "documentation": {}
    },
    {
        "label": "rot_mat_2d",
        "kind": 2,
        "importPath": "Utils.angle.angle",
        "description": "Utils.angle.angle",
        "peekOfCode": "def rot_mat_2d(angle):\n    \"\"\"\n    Create 2D rotation matrix from an angle\n    Parameters\n    ----------\n    angle :\n    Returns\n    -------\n    A 2D rotation matrix\n    Examples",
        "detail": "Utils.angle.angle",
        "documentation": {}
    },
    {
        "label": "angle_mod",
        "kind": 2,
        "importPath": "Utils.angle.angle",
        "description": "Utils.angle.angle",
        "peekOfCode": "def angle_mod(x, zero_2_2pi=False, degree=False):\n    \"\"\"\n    Angle modulo operation\n    Default angle modulo range is [-pi, pi)\n    Parameters\n    ----------\n    x : float or array_like\n        A angle or an array of angles. This array is flattened for\n        the calculation. When an angle is provided, a float angle is returned.\n    zero_2_2pi : bool, optional",
        "detail": "Utils.angle.angle",
        "documentation": {}
    },
    {
        "label": "Arrow3D",
        "kind": 6,
        "importPath": "Utils.angle.plot",
        "description": "Utils.angle.plot",
        "peekOfCode": "class Arrow3D(FancyArrowPatch):\n    def __init__(self, x, y, z, dx, dy, dz, *args, **kwargs):\n        super().__init__((0, 0), (0, 0), *args, **kwargs)\n        self._xyz = (x, y, z)\n        self._dxdydz = (dx, dy, dz)\n    def draw(self, renderer):\n        x1, y1, z1 = self._xyz\n        dx, dy, dz = self._dxdydz\n        x2, y2, z2 = (x1 + dx, y1 + dy, z1 + dz)\n        xs, ys, zs = proj_transform((x1, x2), (y1, y2), (z1, z2), self.axes.M)",
        "detail": "Utils.angle.plot",
        "documentation": {}
    },
    {
        "label": "plot_covariance_ellipse",
        "kind": 2,
        "importPath": "Utils.angle.plot",
        "description": "Utils.angle.plot",
        "peekOfCode": "def plot_covariance_ellipse(x, y, cov, chi2=3.0, color=\"-r\", ax=None):\n    \"\"\"\n    This function plots an ellipse that represents a covariance matrix. The ellipse is centered at (x, y) and its shape, size and rotation are determined by the covariance matrix.\n    Parameters:\n    x : (float) The x-coordinate of the center of the ellipse.\n    y : (float) The y-coordinate of the center of the ellipse.\n    cov : (numpy.ndarray) A 2x2 covariance matrix that determines the shape, size, and rotation of the ellipse.\n    chi2 : (float, optional) A scalar value that scales the ellipse size. This value is typically set based on chi-squared distribution quantiles to achieve certain confidence levels (e.g., 3.0 corresponds to ~95% confidence for a 2D Gaussian). Defaults to 3.0.\n    color : (str, optional) The color and line style of the ellipse plot, following matplotlib conventions. Defaults to \"-r\" (a red solid line).\n    ax : (matplotlib.axes.Axes, optional) The Axes object to draw the ellipse on. If None (default), a new figure and axes are created.",
        "detail": "Utils.angle.plot",
        "documentation": {}
    },
    {
        "label": "plot_ellipse",
        "kind": 2,
        "importPath": "Utils.angle.plot",
        "description": "Utils.angle.plot",
        "peekOfCode": "def plot_ellipse(x, y, a, b, angle, color=\"-r\", ax=None, **kwargs):\n    \"\"\"\n    This function plots an ellipse based on the given parameters.\n    Parameters\n    ----------\n    x : (float) The x-coordinate of the center of the ellipse.\n    y : (float) The y-coordinate of the center of the ellipse.\n    a : (float) The length of the semi-major axis of the ellipse.\n    b : (float) The length of the semi-minor axis of the ellipse.\n    angle : (float) The rotation angle of the ellipse, in radians.",
        "detail": "Utils.angle.plot",
        "documentation": {}
    },
    {
        "label": "plot_arrow",
        "kind": 2,
        "importPath": "Utils.angle.plot",
        "description": "Utils.angle.plot",
        "peekOfCode": "def plot_arrow(x, y, yaw, arrow_length=1.0,\n               origin_point_plot_style=\"xr\",\n               head_width=0.1, fc=\"r\", ec=\"k\", **kwargs):\n    \"\"\"\n    Plot an arrow or arrows based on 2D state (x, y, yaw)\n    All optional settings of matplotlib.pyplot.arrow can be used.\n    - matplotlib.pyplot.arrow:\n    https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.arrow.html\n    Parameters\n    ----------",
        "detail": "Utils.angle.plot",
        "documentation": {}
    },
    {
        "label": "plot_curvature",
        "kind": 2,
        "importPath": "Utils.angle.plot",
        "description": "Utils.angle.plot",
        "peekOfCode": "def plot_curvature(x_list, y_list, heading_list, curvature,\n                   k=0.01, c=\"-c\", label=\"Curvature\"):\n    \"\"\"\n    Plot curvature on 2D path. This plot is a line from the original path,\n    the lateral distance from the original path shows curvature magnitude.\n    Left turning shows right side plot, right turning shows left side plot.\n    For straight path, the curvature plot will be on the path, because\n    curvature is 0 on the straight path.\n    Parameters\n    ----------",
        "detail": "Utils.angle.plot",
        "documentation": {}
    },
    {
        "label": "plot_3d_vector_arrow",
        "kind": 2,
        "importPath": "Utils.angle.plot",
        "description": "Utils.angle.plot",
        "peekOfCode": "def plot_3d_vector_arrow(ax, p1, p2):\n    setattr(Axes3D, 'arrow3D', _arrow3D)\n    ax.arrow3D(p1[0], p1[1], p1[2],\n               p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2],\n               mutation_scale=20,\n               arrowstyle=\"-|>\",\n               )\ndef plot_triangle(p1, p2, p3, ax):\n    ax.add_collection3d(art3d.Poly3DCollection([[p1, p2, p3]], color='b'))\ndef set_equal_3d_axis(ax, x_lims, y_lims, z_lims):",
        "detail": "Utils.angle.plot",
        "documentation": {}
    },
    {
        "label": "plot_triangle",
        "kind": 2,
        "importPath": "Utils.angle.plot",
        "description": "Utils.angle.plot",
        "peekOfCode": "def plot_triangle(p1, p2, p3, ax):\n    ax.add_collection3d(art3d.Poly3DCollection([[p1, p2, p3]], color='b'))\ndef set_equal_3d_axis(ax, x_lims, y_lims, z_lims):\n    \"\"\"Helper function to set equal axis\n    Args:\n        ax (Axes3DSubplot): matplotlib 3D axis, created by\n        `ax = fig.add_subplot(projection='3d')`\n        x_lims (np.array): array containing min and max value of x\n        y_lims (np.array): array containing min and max value of y\n        z_lims (np.array): array containing min and max value of z",
        "detail": "Utils.angle.plot",
        "documentation": {}
    },
    {
        "label": "set_equal_3d_axis",
        "kind": 2,
        "importPath": "Utils.angle.plot",
        "description": "Utils.angle.plot",
        "peekOfCode": "def set_equal_3d_axis(ax, x_lims, y_lims, z_lims):\n    \"\"\"Helper function to set equal axis\n    Args:\n        ax (Axes3DSubplot): matplotlib 3D axis, created by\n        `ax = fig.add_subplot(projection='3d')`\n        x_lims (np.array): array containing min and max value of x\n        y_lims (np.array): array containing min and max value of y\n        z_lims (np.array): array containing min and max value of z\n    \"\"\"\n    x_lims = np.asarray(x_lims)",
        "detail": "Utils.angle.plot",
        "documentation": {}
    }
]